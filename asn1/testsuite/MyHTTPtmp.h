//
// MyHTTPtmp.h
//
// Code automatically generated by ASN1 compiler
//
#ifndef MyHTTP_H_
#define MyHTTP_H_

#include "asn1.h"

#include "Platform.h"

#if defined(_WIN32)
	#include "Platform_WIN32.h"
#elif defined(__VMS)
	#include "Platform_VMS.h"
#elif defined(ALS_VXWORKS)
	#include "Platform_VX.h"
#elif defined(ALS_OS_FAMILY_UNIX)
	#include "Platform_POSIX.h"
#endif

#if !defined(MyHTTP_API)
	#define MyHTTP_API
#endif


namespace MyHTTP {

//1
// NumberStr01
//
class MyHTTP_API NumberStr01 : public ASN1::NumericString {
	typedef ASN1::NumericString Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	NumberStr01(const void* info) : Inherited(info) {}
public:
	NumberStr01() : Inherited(&theInfo) {}
	NumberStr01(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	NumberStr01(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	NumberStr01(const NumberStr01& that) : Inherited(that) {}
	NumberStr01& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	NumberStr01& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	NumberStr01 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class NumberStr01

//1
// IA5Str01
//
class MyHTTP_API IA5Str01 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str01(const void* info) : Inherited(info) {}
public:
	IA5Str01() : Inherited(&theInfo) {}
	IA5Str01(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str01(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str01(const IA5Str01& that) : Inherited(that) {}
	IA5Str01& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str01& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str01 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str01

//1
// IA5Str02
//
class MyHTTP_API IA5Str02 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str02(const void* info) : Inherited(info) {}
public:
	IA5Str02() : Inherited(&theInfo) {}
	IA5Str02(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str02(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str02(const IA5Str02& that) : Inherited(that) {}
	IA5Str02& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str02& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str02 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str02

//1
// IA5Str03
//
class MyHTTP_API IA5Str03 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str03(const void* info) : Inherited(info) {}
public:
	IA5Str03() : Inherited(&theInfo) {}
	IA5Str03(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str03(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str03(const IA5Str03& that) : Inherited(that) {}
	IA5Str03& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str03& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str03 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str03

//1
// IA5Str05
//
class MyHTTP_API IA5Str05 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str05(const void* info) : Inherited(info) {}
public:
	IA5Str05() : Inherited(&theInfo) {}
	IA5Str05(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str05(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str05(const IA5Str05& that) : Inherited(that) {}
	IA5Str05& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str05& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str05 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str05

//1
// IA5Str08
//
class MyHTTP_API IA5Str08 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str08(const void* info) : Inherited(info) {}
public:
	IA5Str08() : Inherited(&theInfo) {}
	IA5Str08(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str08(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str08(const IA5Str08& that) : Inherited(that) {}
	IA5Str08& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str08& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str08 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str08

//1
// IA5Str09
//
class MyHTTP_API IA5Str09 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str09(const void* info) : Inherited(info) {}
public:
	IA5Str09() : Inherited(&theInfo) {}
	IA5Str09(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str09(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str09(const IA5Str09& that) : Inherited(that) {}
	IA5Str09& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str09& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str09 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str09

//1
// IA5Str10
//
class MyHTTP_API IA5Str10 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str10(const void* info) : Inherited(info) {}
public:
	IA5Str10() : Inherited(&theInfo) {}
	IA5Str10(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str10(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str10(const IA5Str10& that) : Inherited(that) {}
	IA5Str10& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str10& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str10 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str10

//1
// IA5Str11
//
class MyHTTP_API IA5Str11 : public ASN1::IA5String {
	typedef ASN1::IA5String Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	IA5Str11(const void* info) : Inherited(info) {}
public:
	IA5Str11() : Inherited(&theInfo) {}
	IA5Str11(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str11(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	IA5Str11(const IA5Str11& that) : Inherited(that) {}
	IA5Str11& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	IA5Str11& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	IA5Str11 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class IA5Str11

//1
// RejectProblem
//
class MyHTTP_API RejectProblem : public ASN1::IntegerWithNamedNumber {
	typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	RejectProblem(const void* info) : Inherited(info) {}
public:
	RejectProblem(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
	enum NamedNumber {
		general_unrecognizedPDU,
		general_mistypedPDU,
		general_badlyStructuredPDU,
		invoke_duplicateInvocation = 10,
		invoke_unrecognizedOperation,
		invoke_mistypedArgument,
		invoke_resourceLimitation,
		invoke_releaseInProgress,
		invoke_unrecognizedLinkedId,
		invoke_linkedResponseUnexpected,
		invoke_unexpectedLinkedOperation,
		returnResult_unrecognizedInvocation = 20,
		returnResult_resultResponseUnexpected,
		returnResult_mistypedResult,
		returnError_unrecognizedInvocation = 30,
		returnError_errorResponseUnexpected,
		returnError_unrecognizedError,
		returnError_unexpectedError,
		returnError_mistypedParameter
	};

	bool is_general_unrecognizedPDU() const { return value == general_unrecognizedPDU; }
	void set_general_unrecognizedPDU() { value = general_unrecognizedPDU; }

	bool is_general_mistypedPDU() const { return value == general_mistypedPDU; }
	void set_general_mistypedPDU() { value = general_mistypedPDU; }

	bool is_general_badlyStructuredPDU() const { return value == general_badlyStructuredPDU; }
	void set_general_badlyStructuredPDU() { value = general_badlyStructuredPDU; }

	bool is_invoke_duplicateInvocation() const { return value == invoke_duplicateInvocation; }
	void set_invoke_duplicateInvocation() { value = invoke_duplicateInvocation; }

	bool is_invoke_unrecognizedOperation() const { return value == invoke_unrecognizedOperation; }
	void set_invoke_unrecognizedOperation() { value = invoke_unrecognizedOperation; }

	bool is_invoke_mistypedArgument() const { return value == invoke_mistypedArgument; }
	void set_invoke_mistypedArgument() { value = invoke_mistypedArgument; }

	bool is_invoke_resourceLimitation() const { return value == invoke_resourceLimitation; }
	void set_invoke_resourceLimitation() { value = invoke_resourceLimitation; }

	bool is_invoke_releaseInProgress() const { return value == invoke_releaseInProgress; }
	void set_invoke_releaseInProgress() { value = invoke_releaseInProgress; }

	bool is_invoke_unrecognizedLinkedId() const { return value == invoke_unrecognizedLinkedId; }
	void set_invoke_unrecognizedLinkedId() { value = invoke_unrecognizedLinkedId; }

	bool is_invoke_linkedResponseUnexpected() const { return value == invoke_linkedResponseUnexpected; }
	void set_invoke_linkedResponseUnexpected() { value = invoke_linkedResponseUnexpected; }

	bool is_invoke_unexpectedLinkedOperation() const { return value == invoke_unexpectedLinkedOperation; }
	void set_invoke_unexpectedLinkedOperation() { value = invoke_unexpectedLinkedOperation; }

	bool is_returnResult_unrecognizedInvocation() const { return value == returnResult_unrecognizedInvocation; }
	void set_returnResult_unrecognizedInvocation() { value = returnResult_unrecognizedInvocation; }

	bool is_returnResult_resultResponseUnexpected() const { return value == returnResult_resultResponseUnexpected; }
	void set_returnResult_resultResponseUnexpected() { value = returnResult_resultResponseUnexpected; }

	bool is_returnResult_mistypedResult() const { return value == returnResult_mistypedResult; }
	void set_returnResult_mistypedResult() { value = returnResult_mistypedResult; }

	bool is_returnError_unrecognizedInvocation() const { return value == returnError_unrecognizedInvocation; }
	void set_returnError_unrecognizedInvocation() { value = returnError_unrecognizedInvocation; }

	bool is_returnError_errorResponseUnexpected() const { return value == returnError_errorResponseUnexpected; }
	void set_returnError_errorResponseUnexpected() { value = returnError_errorResponseUnexpected; }

	bool is_returnError_unrecognizedError() const { return value == returnError_unrecognizedError; }
	void set_returnError_unrecognizedError() { value = returnError_unrecognizedError; }

	bool is_returnError_unexpectedError() const { return value == returnError_unexpectedError; }
	void set_returnError_unexpectedError() { value = returnError_unexpectedError; }

	bool is_returnError_mistypedParameter() const { return value == returnError_mistypedParameter; }
	void set_returnError_mistypedParameter() { value = returnError_mistypedParameter; }

	RejectProblem(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
	RejectProblem& operator=(int_type v) { setValue(v); return *this; }
	operator NamedNumber() const { return NamedNumber(getValue()); }

	RejectProblem * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class RejectProblem

//1
// AcceptTypes_others_subtype
//
class MyHTTP_API AcceptTypes_others_subtype : public ASN1::VisibleString {
	typedef ASN1::VisibleString Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	AcceptTypes_others_subtype(const void* info) : Inherited(info) {}
public:
	AcceptTypes_others_subtype() : Inherited(&theInfo) {}
	AcceptTypes_others_subtype(const base_string& str, const void* info =&theInfo) : Inherited(str, info) {}
	AcceptTypes_others_subtype(const char* str, const void* info =&theInfo) : Inherited(str, info) {}
	AcceptTypes_others_subtype(const AcceptTypes_others_subtype& that) : Inherited(that) {}
	AcceptTypes_others_subtype& operator=(const ASN1_STD string& that)
	{ Inherited::operator=(that); return *this; }
	AcceptTypes_others_subtype& operator=(const char* that)
	{ Inherited::operator=(that); return *this; }
	AcceptTypes_others_subtype * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
}; // end class AcceptTypes_others_subtype

//1
// AcceptTypes
//
class MyHTTP_API AcceptTypes : public ASN1::SET {
	typedef ASN1::SET Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	AcceptTypes(const void* info) : Inherited(info) {}
public:
	AcceptTypes() : Inherited(&theInfo) {}
	AcceptTypes(const AcceptTypes& that) : Inherited(that) {}

	AcceptTypes& operator=(const AcceptTypes& that) { Inherited::operator=(that); return *this; }

	enum OptionalFields {
	  e_standards,
	  e_others
	};

	class standards {
	public:
		//1
		// value_type
		//
		class MyHTTP_API value_type : public ASN1::Constrained_BIT_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> >  {
			typedef ASN1::Constrained_BIT_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> >  Inherited;
		protected:
			typedef Inherited::InfoType InfoType;
			value_type(const void* info) : Inherited(info) {}
		public:
			value_type() : Inherited(&theInfo) {}

			enum NamedBits {
				html,
				plain_text,
				gif,
				jpeg
			};

			value_type * clone() const;
			static bool equal_type(const ASN1::AbstractData& type);
				static const InfoType theInfo;
			private:
				static const char * nameList[];
		}; // end class value_type

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class standards

	standards::const_reference get_standards () const;
	standards::reference ref_standards ();
	standards::reference set_standards ();
	standards::reference set_standards (standards::const_reference v);
	void omit_standards ();
	bool standards_isPresent () const;

	class others {
	public:
		//8
		// value_type
		//
		typedef AcceptTypes_others value_type;
		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class others

	others::const_reference get_others () const;
	others::reference ref_others ();
	others::reference set_others ();
	others::reference set_others (others::const_reference v);
	void omit_others ();
	bool others_isPresent () const;
	void swap(AcceptTypes& that);
	AcceptTypes * clone() const;
	static const Inherited::InfoType theInfo;

private:
	static const void* fieldInfos[2];
	static int fieldIds[2];
	static const char* fieldNames[2];
}; // end class AcceptTypes

//1
// GetRequest
//
class MyHTTP_API GetRequest : public ASN1::SEQUENCE {
	typedef ASN1::SEQUENCE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	GetRequest(const void* info) : Inherited(info) {}
public:
	GetRequest() : Inherited(&theInfo) {}
	GetRequest(const GetRequest& that) : Inherited(that) {}

	GetRequest& operator=(const GetRequest& that) { Inherited::operator=(that); return *this; }

	enum OptionalFields {
	  e_header_only,
	  e_lock,
	  e_accept_types
	};

	class header_only {
	public:
		//7
		// value_type
		//
		typedef ASN1::BOOLEAN value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class header_only

	header_only::const_reference get_header_only () const;
	header_only::reference ref_header_only ();
	header_only::reference set_header_only ();
	header_only::reference set_header_only (bool v);
	void omit_header_only ();
	bool header_only_isPresent () const;

	class lock {
	public:
		//7
		// value_type
		//
		typedef ASN1::BOOLEAN value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class lock

	lock::const_reference get_lock () const;
	lock::reference ref_lock ();
	lock::reference set_lock ();
	lock::reference set_lock (bool v);
	void omit_lock ();
	bool lock_isPresent () const;

	class accept_types {
	public:
		//8
		// value_type
		//
		typedef AcceptTypes value_type;
		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class accept_types

	accept_types::const_reference get_accept_types () const;
	accept_types::reference ref_accept_types ();
	accept_types::reference set_accept_types ();
	accept_types::reference set_accept_types (accept_types::const_reference v);
	void omit_accept_types ();
	bool accept_types_isPresent () const;

	class url {
	public:
		//8
		// value_type
		//
		typedef Url value_type;
		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class url

	url::const_reference get_url () const;
	url::reference ref_url ();
	url::reference set_url ();
	url::reference set_url (const ASN1_STD string& v);
	void swap(GetRequest& that);
	GetRequest * clone() const;
	static const Inherited::InfoType theInfo;

private:
	static const void* fieldInfos[4];
	static int fieldIds[4];
	static const char* fieldNames[4];
}; // end class GetRequest

//6
// Module
//
#include "MyHTTP.inl"

} // namespace MyHTTP

#endif // MyHTTP_H_

// end of MyHTTPtmp.h
