//
// TEST1tmp.h
//
// Code automatically generated by ASN1 compiler
//
#ifndef TEST1_H_
#define TEST1_H_

#include "asn1.h"

#include "Platform.h"

#if defined(_WIN32)
	#include "Platform_WIN32.h"
#elif defined(__VMS)
	#include "Platform_VMS.h"
#elif defined(ALS_VXWORKS)
	#include "Platform_VX.h"
#elif defined(ALS_OS_FAMILY_UNIX)
	#include "Platform_POSIX.h"
#endif

#if !defined(TEST1_API)
	#define TEST1_API
#endif


namespace TEST1 {


//
// Type forward declaration
//

//1
// Choice1
//
class Choice1;
//1
// Choice2
//
class Choice2;
//1
// Choice3
//
class Choice3;
//7
// S1
//
typedef ASN1::SEQUENCE_OF<ASN1::INTEGER>  S1;

//7
// S2
//
typedef ASN1::SET_OF<ASN1::INTEGER>  S2;

//1
// S3
//
class S3;
//1
// Choice4_f2
//
class Choice4_f2;
//1
// Choice4
//
class Choice4;
//1
// S4
//
class S4;
//1
// Choice1
//
class TEST1_API Choice1 : public ASN1::CHOICE {
	typedef ASN1::CHOICE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	Choice1(const void* info) : Inherited(info) {}
public:
	Choice1() : Inherited(&theInfo) {}
	enum Choice_Ids {
		unknownSelection_ = -2,
		unselected_ = -1,
		name0 = 0,
		nobody1 = 1
	};

	class name {
	public:
		enum Id { eid = 0 };
		//7
		// value_type
		//
		typedef ASN1::VisibleString value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class name

	name::const_reference get_name () const;
	name::reference ref_name ();
	name::reference select_name ();
	name::reference select_name (const ASN1_STD string& v);
	bool name_isSelected() const;

	Choice1(name::Id id, const ASN1_STD string& v);

	class nobody {
	public:
		enum Id { eid = 1 };
		//7
		// value_type
		//
		typedef ASN1::Null value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class nobody

	nobody::reference select_nobody ();
	bool nobody_isSelected() const;

	Choice1(nobody::Id id, nobody::const_reference v);
	Choice1(const Choice1& that) : Inherited(that) {}

	Choice1& operator=(const Choice1& that) { Inherited::operator=(that); return *this; }

	void swap(Choice1& that) { Inherited::swap(that); }

	Choice1 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
private:
	static const void* selectionInfos[2];
	static unsigned selectionTags[2];
	static const char* selectionNames[2];
}; // end class Choice1

//1
// Choice2
//
class TEST1_API Choice2 : public ASN1::CHOICE {
	typedef ASN1::CHOICE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	Choice2(const void* info) : Inherited(info) {}
public:
	Choice2() : Inherited(&theInfo) {}
	enum Choice_Ids {
		unknownSelection_ = -2,
		unselected_ = -1,
		name0 = 0,
		nobody1 = 1
	};

	class name {
	public:
		enum Id { eid = 0 };
		//7
		// value_type
		//
		typedef ASN1::VisibleString value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class name

	name::const_reference get_name () const;
	name::reference ref_name ();
	name::reference select_name ();
	name::reference select_name (const ASN1_STD string& v);
	bool name_isSelected() const;

	Choice2(name::Id id, const ASN1_STD string& v);

	class nobody {
	public:
		enum Id { eid = 1 };
		//7
		// value_type
		//
		typedef ASN1::Null value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class nobody

	nobody::reference select_nobody ();
	bool nobody_isSelected() const;

	Choice2(nobody::Id id, nobody::const_reference v);
	Choice2(const Choice2& that) : Inherited(that) {}

	Choice2& operator=(const Choice2& that) { Inherited::operator=(that); return *this; }

	void swap(Choice2& that) { Inherited::swap(that); }

	Choice2 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
private:
	static const void* selectionInfos[2];
	static unsigned selectionTags[2];
	static const char* selectionNames[2];
}; // end class Choice2

//1
// Choice3
//
class TEST1_API Choice3 : public ASN1::CHOICE {
	typedef ASN1::CHOICE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	Choice3(const void* info) : Inherited(info) {}
public:
	Choice3() : Inherited(&theInfo) {}
	enum Choice_Ids {
		unknownSelection_ = -2,
		unselected_ = -1,
		name0 = 0,
		nobody1 = 1
	};

	class name {
	public:
		enum Id { eid = 0 };
		//7
		// value_type
		//
		typedef ASN1::VisibleString value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class name

	name::const_reference get_name () const;
	name::reference ref_name ();
	name::reference select_name ();
	name::reference select_name (const ASN1_STD string& v);
	bool name_isSelected() const;

	Choice3(name::Id id, const ASN1_STD string& v);

	class nobody {
	public:
		enum Id { eid = 1 };
		//7
		// value_type
		//
		typedef ASN1::Null value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class nobody

	nobody::reference select_nobody ();
	bool nobody_isSelected() const;

	Choice3(nobody::Id id, nobody::const_reference v);
	Choice3(const Choice3& that) : Inherited(that) {}

	Choice3& operator=(const Choice3& that) { Inherited::operator=(that); return *this; }

	void swap(Choice3& that) { Inherited::swap(that); }

	Choice3 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
private:
	static const void* selectionInfos[2];
	static unsigned selectionTags[2];
	static const char* selectionNames[2];
}; // end class Choice3

//1
// S3
//
class TEST1_API S3 : public ASN1::SEQUENCE {
	typedef ASN1::SEQUENCE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	S3(const void* info) : Inherited(info) {}
public:
	S3() : Inherited(&theInfo) {}
	S3(const S3& that) : Inherited(that) {}

	S3& operator=(const S3& that) { Inherited::operator=(that); return *this; }


	class age {
	public:
		//7
		// value_type
		//
		typedef ASN1::INTEGER value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class age

	age::const_reference get_age () const;
	age::reference ref_age ();
	age::reference set_age ();
	age::reference set_age (age::value_type::int_type v);

	class single {
	public:
		//7
		// value_type
		//
		typedef ASN1::BOOLEAN value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class single

	single::const_reference get_single () const;
	single::reference ref_single ();
	single::reference set_single ();
	single::reference set_single (bool v);
	void swap(S3& that);
	S3 * clone() const;
	static const Inherited::InfoType theInfo;

private:
	static const void* fieldInfos[2];
	static int fieldIds[2];
	static const char* fieldNames[2];
}; // end class S3

//1
// Choice4_f2
//
class TEST1_API Choice4_f2 : public ASN1::CHOICE {
	typedef ASN1::CHOICE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	Choice4_f2(const void* info) : Inherited(info) {}
public:
	Choice4_f2() : Inherited(&theInfo) {}
	enum Choice_Ids {
		unknownSelection_ = -2,
		unselected_ = -1,
		f30 = 0,
		f41 = 1
	};

	class f3 {
	public:
		enum Id { eid = 0 };
		//7
		// value_type
		//
		typedef ASN1::BOOLEAN value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class f3

	f3::const_reference get_f3 () const;
	f3::reference ref_f3 ();
	f3::reference select_f3 ();
	f3::reference select_f3 (bool v);
	bool f3_isSelected() const;

	Choice4_f2(f3::Id id, bool v);

	class f4 {
	public:
		enum Id { eid = 1 };
		//7
		// value_type
		//
		typedef ASN1::INTEGER value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class f4

	f4::const_reference get_f4 () const;
	f4::reference ref_f4 ();
	f4::reference select_f4 ();
	f4::reference select_f4 (f4::value_type::int_type v);
	bool f4_isSelected() const;

	Choice4_f2(f4::Id id, f4::value_type::int_type v);
	Choice4_f2(const Choice4_f2& that) : Inherited(that) {}

	Choice4_f2& operator=(const Choice4_f2& that) { Inherited::operator=(that); return *this; }

	void swap(Choice4_f2& that) { Inherited::swap(that); }

	Choice4_f2 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
private:
	static const void* selectionInfos[2];
	static unsigned selectionTags[2];
	static const char* selectionNames[2];
}; // end class Choice4_f2

//1
// Choice4
//
class TEST1_API Choice4 : public ASN1::CHOICE {
	typedef ASN1::CHOICE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	Choice4(const void* info) : Inherited(info) {}
public:
	Choice4() : Inherited(&theInfo) {}
	enum Choice_Ids {
		unknownSelection_ = -2,
		unselected_ = -1,
		f20 = 0,
		f11 = 1
	};

	class f2 {
	public:
		enum Id { eid = 0 };
		//8
		// value_type
		//
		typedef Choice4_f2 value_type;
		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class f2

	f2::const_reference get_f2 () const;
	f2::reference ref_f2 ();
	f2::reference select_f2 ();
	f2::reference select_f2 (f2::const_reference v);
	bool f2_isSelected() const;

	Choice4(f2::Id id, f2::const_reference v);

	class f1 {
	public:
		enum Id { eid = 1 };
		//7
		// value_type
		//
		typedef ASN1::Null value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class f1

	f1::reference select_f1 ();
	bool f1_isSelected() const;

	Choice4(f1::Id id, f1::const_reference v);
	Choice4(const Choice4& that) : Inherited(that) {}

	Choice4& operator=(const Choice4& that) { Inherited::operator=(that); return *this; }

	void swap(Choice4& that) { Inherited::swap(that); }

	Choice4 * clone() const;
	static bool equal_type(const ASN1::AbstractData& type);
	static const InfoType theInfo;
private:
	static const void* selectionInfos[2];
	static unsigned selectionTags[2];
	static const char* selectionNames[2];
}; // end class Choice4

//1
// S4
//
class TEST1_API S4 : public ASN1::SEQUENCE {
	typedef ASN1::SEQUENCE Inherited;
protected:
	typedef Inherited::InfoType InfoType;
	S4(const void* info) : Inherited(info) {}
public:
	S4() : Inherited(&theInfo) {}
	S4(const S4& that) : Inherited(that) {}

	S4& operator=(const S4& that) { Inherited::operator=(that); return *this; }


	class name {
	public:
		//7
		// value_type
		//
		typedef ASN1::VisibleString value_type;

		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class name

	name::const_reference get_name () const;
	name::reference ref_name ();
	name::reference set_name ();
	name::reference set_name (const ASN1_STD string& v);

	class attrib {
	public:
		//8
		// value_type
		//
		typedef Choice4 value_type;
		typedef value_type&        reference;
		typedef const value_type&  const_reference;
		typedef value_type*        pointer;
		typedef const value_type*  const_pointer;
	}; // end class attrib

	attrib::const_reference get_attrib () const;
	attrib::reference ref_attrib ();
	attrib::reference set_attrib ();
	attrib::reference set_attrib (attrib::const_reference v);
	void swap(S4& that);
	S4 * clone() const;
	static const Inherited::InfoType theInfo;

private:
	static const void* fieldInfos[2];
	static int fieldIds[2];
	static const char* fieldNames[2];
}; // end class S4

//6
// Module
//
#include "TEST1.inl"

} // namespace TEST1

#endif // TEST1_H_

// end of TEST1tmp.h
