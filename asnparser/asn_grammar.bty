/*
%glr-parser
%expect-rr 1
%expect 19
*/

/*
%define api.pure		full
*/
%lex-param				{ yyscan_t scanner } { ParserContext* context } { void* yytrial }
%parse-param			{ yyscan_t scanner } { ParserContext* context }
%locations
%no-lines

%{
/*
 * asn_grammar.bty
 *
 * ASN grammar file
 *
 * ASN.1 compiler to produce C++ classes.
 *
 * Copyright (c) 1997-1999 Equivalence Pty. Ltd.
 *
 * Copyright (c) 2001 Institute for Information Industry, Taiwan, Republic of China
 * (http://www.iii.org.tw/iiia/ewelcome.htm)
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 * the License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is ASN Parser.
 *
 * The Initial Developer of the Original Code is Equivalence Pty. Ltd.
 *
 * Portions of this code were written with the assisance of funding from
 * Vovida Networks, Inc. http://www.vovida.com.
 *
 * Portions are Copyright (C) 1993 Free Software Foundation, Inc.
 * All Rights Reserved.
 *
 * The code is modified by Genesys Telecommunications Labs UK, 2003-2011
 * Contributors: 
 *    Arunas Ruksnaitis <arunas.ruksnaitis@genesyslab.com>
 *    Rustam Mirzaev <rustam.mirzaev@genesyslab.com>
 *
 */

#undef malloc
#undef calloc
#undef realloc
#undef free
#include <sstream>
#include "main.h"

static int UnnamedFieldCount = 1;

static std::string * ConcatNames(std::string * s1, char c, std::string * s2) {
  *s1 += c;*s1 += *s2;delete s2;return s1;
}

#define YYERROR_VERBOSE 1
#define YYPRINT(a,b,c)

extern int yydebug;
extern int iddebug;
%}

%token MODULEREFERENCE
%token TYPEREFERENCE
%token OBJECTCLASSREFERENCE
%token VALUEREFERENCE
%token OBJECTREFERENCE
%token OBJECTSETREFERENCE

%token PARAMETERIZEDTYPEREFERENCE
%token PARAMETERIZEDOBJECTCLASSREFERENCE
%token PARAMETERIZEDVALUEREFERENCE
%token PARAMETERIZEDOBJECTREFERENCE
%token PARAMETERIZEDOBJECTSETREFERENCE

%token VALUESET_BRACE
%token OBJECT_BRACE
%token OBJECTSET_BRACE
%token OID_BRACE

%token IDENTIFIER
%token BIT_IDENTIFIER
%token OID_IDENTIFIER
%token OID_INTEGER
%token IMPORT_IDENTIFIER
%token fieldreference
%token FieldReference
%token TYPEFIELDREFERENCE
%token FIXEDTYPEVALUEFIELDREFERENCE
%token VARIABLETYPEVALUEFIELDREFERENCE
%token FIXEDTYPEVALUESETFIELDREFERENCE
%token VARIABLETYPEVALUESETFIELDREFERENCE
%token OBJECTFIELDREFERENCE
%token OBJECTSETFIELDREFERENCE
%token INTEGER
%token REAL

%token CSTRING
%token BSTRING
%token HSTRING
%token BS_BSTRING
%token BS_HSTRING


%token ABSENT
%token ABSTRACT_SYNTAX
%token ALL
%token ANY
%token APPLICATION
%token ASSIGNMENT
%token AUTOMATIC
%token BEGIN_t
%token BIT
%token BMPString
%token BOOLEAN_t
%token BY
%token CHARACTER
%token CHOICE
%token CLASS
%token COMPONENT
%token COMPONENTS
%token CONSTRAINED
%token CONTAINING
%token DEFAULT
%token DEFINED
%token DEFINITIONS
%token ELLIPSIS
%token EMBEDDED
%token END
%token ENUMERATED
%token EXCEPT
%token EXPLICIT
%token EXPORTS
%token EXTENSIBILITY
%token EXTERNAL
%token FALSE_t
%token FROM
%token GeneralString
%token GeneralizedTime
%token GraphicString
%token IA5String
%token IDENTIFIER_t
%token IMPLICIT
%token IMPLIED
%token IMPORTS
%token INCLUDES
%token INSTANCE
%token INSTRUCTIONS
%token INTEGER_t
%token INTERSECTION
%token ISO646String
%token MACRO
%token MAX
%token MIN
%token MINUS_INFINITY
%token NOTATION
%token NOT_A_NUMBER
%token NULL_TYPE
%token NULL_VALUE
%token NumericString
%token OBJECT
%token OCTET
%token OID_IRI
%token OF_t
%token OPTIONAL_t
%token PATTERN
%token PDV
%token PLUS_INFINITY
%token PRESENT
%token PRIVATE
%token PrintableString
%token RANGE
%token REAL_t
%token RELATIVE_OID
%token RELATIVE_OID_IRI
%token SEQUENCE
%token SET
%token SETTINGS
%token SIZE_t
%token STRING
%token SYNTAX
%token T61String
%token TAGS
%token TRUE_t
%token TYPE_IDENTIFIER
%token TYPE_t
%token TeletexString
%token UNION
%token UNIQUE
%token UNIVERSAL
%token UTCTime
%token UTF8String
%token UniversalString
%token VALUE
%token VideotexString
%token VisibleString
%token WITH
%token ObjectDescriptor_t
%token WORD_t
 

%type <modd> ModuleDefinition

%type <sval> CSTRING
%type <sval> BSTRING
%type <sval> HSTRING
%type <sval> BS_BSTRING
%type <sval> BS_HSTRING
%type <sval> IDENTIFIER
%type <sval> BIT_IDENTIFIER
%type <sval> OID_IDENTIFIER
%type <sval> IMPORT_IDENTIFIER
%type <sval> TYPEREFERENCE
%type <sval> MODULEREFERENCE
%type <sval> OBJECTCLASSREFERENCE
%type <sval> VALUEREFERENCE
%type <sval> fieldreference FieldReference
%type <sval> TYPEFIELDREFERENCE
%type <sval> VALUEFIELDREFERENCE
%type <sval> FIXEDTYPEVALUEFIELDREFERENCE
%type <sval> VARIABLETYPEVALUEFIELDREFERENCE
%type <sval> VALUESETFIELDREFERENCE
%type <sval> FIXEDTYPEVALUESETFIELDREFERENCE
%type <sval> VARIABLETYPEVALUESETFIELDREFERENCE
%type <sval> OBJECTFIELDREFERENCE
%type <sval> OBJECTSETFIELDREFERENCE
%type <sval> OBJECTREFERENCE
%type <sval> OBJECTSETREFERENCE
%type <sval> DefinitiveObjIdComponent
%type <sval> DefinitiveNameAndNumberForm
%type <sval> GlobalModuleReference
%type <sval> Reference
%type <sval> ExternalTypeReference ExternalValueReference
%type <sval> SimpleDefinedType
%type <sval> CharsDefn
%type <sval> SimpleDefinedValue
%type <sval> FieldName PrimitiveFieldName
%type <sval> ExternalObjectClassReference
%type <sval> UsefulObjectClassReference
%type <sval> PARAMETERIZEDTYPEREFERENCE
%type <sval> PARAMETERIZEDOBJECTCLASSREFERENCE
%type <sval> PARAMETERIZEDVALUEREFERENCE
%type <sval> PARAMETERIZEDOBJECTREFERENCE
%type <sval> PARAMETERIZEDOBJECTSETREFERENCE
%type <sval> WORD_t
%type <sval> Literal
%type <sval> ExternalObjectSetReference
%type <sval> AtNotation ComponentIdList
%type <sval> ExternalObjectReference
%type <sval> PropertySettings

%type <ival>	INTEGER
%type <ival>	TagDefault
%type <ival>	SignedNumber
%type <ival>	Class ClassNumber
%type <ival>	PresenceConstraint
%type <ival>	OID_INTEGER

%type <oic>		ObjIdComponent
%type <nf>		NumberForm
%type <nf>		NumberFormOptional


%type <slst> DefinitiveIdentification ModuleIdentifier
%type <slst> DefinitiveObjIdComponentList DefinitiveOID
%type <slst> BitIdentifierList
%type <slst> CharSyms

%type <oiclst> ObjIdComponentList 

%type <tval> Type BuiltinType ReferencedType NamedType TypeOrNamedType
%type <tval> DefinedType
%type <tval> ConstrainedType
%type <tval> TypeWithConstraint
%type <tval> BitStringType
%type <tval> BooleanType
%type <tval> CharacterStringType
%type <tval> RestrictedCharacterStringType
%type <tval> UnrestrictedCharacterStringType
%type <tval> ChoiceType AlternativeTypeLists
%type <tval> EmbeddedPDVType
%type <tval> EnumeratedType Enumerations
%type <tval> ExternalType
//%type <tval> AnyType
%type <tval> IntegerType
%type <tval> NullType
%type <tval> ObjectClassFieldType
%type <tval> ObjectIdentifierType RelativeOIDType
%type <tval> OctetStringType
%type <tval> RealType
%type <tval> SequenceType ComponentTypeLists 
%type <tval> SequenceOfType
%type <tval> SetType
%type <tval> SetOfType 
%type <tval> TaggedType
%type <tval> ParameterizedType
%type <tval> SelectionType
%type <tval> UsefulType
%type <tval> TypeFromObject
%type <tval> ContainedSubtype

%type <ocft> SimpleObjectClassFieldType
%type <tptr> ComponentType


%type <tlst> AlternativeTypeList
%type <tlst> ComponentTypeList RootComponentTypeList

%type <symb> Symbol
%type <syml> SymbolList

%type <vval> Value BuiltinValue
%type <vval> AssignedIdentifier
%type <vval> DefinedValue
%type <vval> ObjectIdentifierValue RelativeOIDValue
%type <vval> OctetStringValue
%type <vval> BitStringValue
%type <vval> ExceptionSpec
%type <vval> ExceptionIdentification
%type <vval> Lowerendpoint LowerendValue Upperendpoint UpperendValue
%type <vval> ReferencedValue
%type <vval> BooleanValue
%type <vval> CharacterStringValue RestrictedCharacterStringValue
%type <vval> CharacterStringList Quadruple Tuple
%type <vval> ChoiceValue
%type <vval> NullValue
%type <vval> RealValue NumericRealValue SpecialRealValue
%type <vval> SequenceValue NamedValue
/*!!!! %type <vval> SequenceOfValue */
//%type <vval> ParameterizedValue
%type <vval> ValueFromObject

%type <vlst> ComponentValueList

%type <nval> NamedBit
%type <nval> EnumerationItem
%type <nval> NamedNumber

%type <nlst> NamedBitList
%type <nlst> Enumeration
%type <nlst> NamedNumberList

%type <elmt> IntersectionElements
%type <elmt> Elements
%type <elmt> Exclusions
%type <elmt> SubtypeElements SingleValue
%type <elmt> ObjectSetElements
%type <elmt> ValueRange
%type <elmt> PermittedAlphabet
%type <elmt> InnerTypeConstraints
%type <elmt> MultipleTypeConstraints
%type <elmt> SizeConstraint
%type <elmt> UserDefinedConstraintParameterList
%type <elmt> NamedConstraint
%type <elmt> PatternConstraint

%type <elst> ElementSetSpec Unions Intersections TypeConstraints

%type <cons> Constraint
%type <cons> ConstraintSpec
%type <cons> ElementSetSpecs ObjectSetSpec
/* %type <cons> GeneralConstraint */
%type <cons> UserDefinedConstraint
%type <tcons> TableConstraint
%type <tcons> SimpleTableConstraint
%type <tcons> ComponentRelationConstraint
%type <tagv> Tag

%type <fspc> FieldSpec
%type <fspc> TypeFieldSpec
%type <fspc> FixedTypeValueFieldSpec
%type <fspc> VariableTypeValueFieldSpec
%type <fspc> FixedTypeValueSetFieldSpec
%type <fspc> VariableTypeValueSetFieldSpec
%type <fspc> ObjectFieldSpec
%type <fspc> ObjectSetFieldSpec

%type <flst> FieldSpecs

%type <objc> ObjectClass ObjectClassDefn
%type <dobj> DefinedObjectClass
%type <tgrp> WithSyntaxSpec SyntaxList TokenOrGroupSpecs
%type <togs> TokenOrGroupSpec RequiredToken OptionalGroup
%type <sett> Setting

%type <objt> Object
%type <objt> ObjectDefn
%type <objt> DefinedObject
%type <objt> ObjectFromObject
%type <objt> ReferencedObject ReferencedObjectDot
%type <objt> ParameterizedObject ObjectParameter

%type <fldl> FieldSettings
%type <fldl> DefaultSyntax
%type <bldr> DefinedSyntax
%type <bldr> DefinedSyntaxTokens
%type <tken> DefinedSyntaxToken


%type <vset> ValueSet
%type <vset> ValueSetFromObject ValueSetFromObjects

%type <cons> ObjectSet
%type <dos> DefinedObjectSet ParameterizedObjectSet
%type <osce> ReferencedObjects ReferencedObjectsDot
%type <osce> ObjectSetFromObject ObjectSetFromObjects
%type <osce> ObjectSetParameter

%type <para> Parameter
%type <plst> ParameterList Parameters
%type <apar> ActualParameter
%type <aplt> ActualParameterList ActualParameters
%type <apar> UserDefinedConstraintParameter
%type <aplt> UserDefinedConstraintParameters

%type <slst> AtNotations

%union {
  boost::int64_t					ival;
  std::string*						sval;
  StringList* 						slst;
  NumberForm*	 					nf;
  ObjIdComponent* 					oic;
  ObjIdComponentList* 				oiclst;
  TypeBase* 						tval;
  TypePtr* 							tptr;
  TypesVector*						tlst;
  ValueBase*						vval;
  ValuesList*						vlst;
  NamedNumber*						nval;
  NamedNumberList*					nlst;
  Constraint*						cons;
  ConstraintElementVector*			elst;
  ConstraintElementBase*            elmt;
  FieldSpec*						fspc;
  FieldSpecsList*                   flst;
  ObjectClassBase*                  objc;
  DefinedObjectClass*               dobj;
  TokenGroup*                       tgrp;
  TokenOrGroupSpec*                 togs;
  Setting*							sett;
  InformationObject*                objt;
  InformationObjectSet*             objs;
  FieldSettingList*                 fldl;
  DefaultSyntaxBuilder*             bldr;
  DefinedSyntaxToken*               tken;
  ValueSet*							vset;
  ObjectSetConstraintElement*		osce;
  Symbol*							symb;
  SymbolList*						syml;
  Parameter*						para;
  ParameterList*					plst;
  ActualParameter*					apar;
  ActualParameterList*				aplt;
  TableConstraint*					tcons;
  ObjectClassFieldType*				ocft;
  DefinedObjectSet*					dos;
  ModuleDefinition*					modd;

  struct {
    Tag::Type tagClass;
    unsigned tagNumber;
  } tagv;
}

/*
%printer { fprintf (yyoutput, "'%lld'", $$); } <ival>
%printer { if ($$ != nullptr) fprintf (yyoutput, "'%s'", $$->c_str()); } <sval>
%printer { if ($$ != nullptr) fprintf (yyoutput, "'%s'", $$->getName().c_str()); } <tval> <vval> <objt> <para> <symb> <fspc> <objc> <ocft>
*/
%{
#define YYSTYPE_TOSTRING(yychar, yylval) value(yychar, yylval)
static const char* value(int yychar, YYSTYPE yylval);
static void clear(string*& ptr) { delete ptr; ptr = nullptr; }
%}

%%

ModuleDefinitionList
	: ModuleDefinition						      {  }
	| ModuleDefinitionList ModuleDefinition		  {  } 
;
ModuleDefinition
	: ModuleIdentifier DEFINITIONS EncodingReferenceDefault TagDefault ExtensionDefault ASSIGNMENT BEGIN_t {
		if ($1) {
			context->module->setDefinitiveObjId(*$1); delete $1;
		}
	}
	ModuleBody END {
		//context->module->resolveObjectClassReferences();
		context->module = nullptr;
	}
;

ModuleIdentifier 			
	: MODULEREFERENCE  { context->module = findModule($1->c_str());	} 
	  DefinitiveIdentification { $$ = $2; };

DefinitiveIdentification 	: DefinitiveOID | DefinitiveOIDandIRI | /*empty*/;

DefinitiveOID
	: '{'								[ context->inOIDContext = TRUE; context->inOIDLiteral = TRUE; ]
	DefinitiveObjIdComponentList '}'	[ context->inOIDContext = FALSE; context->inOIDLiteral = FALSE; ] { $$ = $3; }
	| DefinitiveOIDandIRI
	| /*empty*/	{ $$ = nullptr;	}
;

DefinitiveObjIdComponentList
	: DefinitiveObjIdComponent								{ $$ = new StringList; $$->push_back($1->c_str());delete $1; }
	| DefinitiveObjIdComponent DefinitiveObjIdComponentList { $2->insert($2->begin(), std::string(*$1));$$ = $2; }
;

DefinitiveObjIdComponent
	: OID_IDENTIFIER
	| OID_INTEGER	{ char buf[10];	sprintf(buf, "%u", static_cast<unsigned>($1));	$$ = new std::string(buf);  }
	| DefinitiveNameAndNumberForm
;

DefinitiveNameAndNumberForm
	: OID_IDENTIFIER '(' OID_INTEGER ')'{
		delete $1;
		char buf[10];
		sprintf(buf, "%u", static_cast<unsigned>($3));
		$$ = new std::string(buf);
      }
;
DefinitiveOIDandIRI 		: DefinitiveOID IRIValue ;
IRIType 					: OID_IRI ;
IRIValue 					: '"' FirstArcIdentifier SubsequentArcIdentifier '"' ;
FirstArcIdentifier 			: '/' ArcIdentifier ;
SubsequentArcIdentifier		: '/' ArcIdentifier SubsequentArcIdentifier | /*empty*/ ;
ArcIdentifier 				: INTEGER;// integerUnicodeLabel | non-integerUnicodeLabel ;
RelativeIRIType 			: RELATIVE_OID_IRI ;
RelativeIRIValue 			: '"' FirstRelativeArcIdentifier SubsequentArcIdentifier '"' ;
FirstRelativeArcIdentifier 	: ArcIdentifier ;


EncodingReferenceDefault 	
//	: encodingreference INSTRUCTIONS FIXME
	: IDENTIFIER INSTRUCTIONS 
	| /*empty*/
;

TagDefault
	: EXPLICIT TAGS			{	$$ = Tag::Explicit; }
	| IMPLICIT TAGS			{	$$ = Tag::Implicit; }
	| AUTOMATIC TAGS		{	$$ = Tag::Automatic; }
	| /*empty*/				{	$$ = Tag::Explicit; }
;

ExtensionDefault
	: EXTENSIBILITY IMPLIED 
	| /*empty*/
;

ModuleBody
	: Exports Imports AssignmentList
	| /*empty*/
;

Exports
	: EXPORTS SymbolsExported ';'
	| /*empty*/
;

SymbolsExported
	: SymbolList			{ context->module->setExports(*$1);	delete $1; }
	| /*empty*/				{ context->module->setExportAll(); }
;

Imports
	: IMPORTS SymbolsImported ';'
	| /*empty*/
;


SymbolsImported
	: SymbolsFromModuleList
	| /*empty*/
;

SymbolsFromModuleList
	: SymbolsFromModule
	| SymbolsFromModuleList SymbolsFromModule
;


SymbolsFromModule
	: SymbolList FROM GlobalModuleReference
      {
		if (!context->hasObjectTypeMacro) {
			context->hasObjectTypeMacro = findWithName(*$1,"OBJECT-TYPE").get() != nullptr;
			if (context->hasObjectTypeMacro)
				std::cerr << "Info: including OBJECT-TYPE macro" << std::endl;
		}
		context->module->addImport(ImportModulePtr(new ImportModule($3, $1)));
      }
;


GlobalModuleReference
	: MODULEREFERENCE			[	context->inOIDContext = TRUE; context->braceTokenContext = OID_BRACE;	]
	  AssignedIdentifier		[	context->inOIDContext = FALSE;context->braceTokenContext = '{'; ] { delete $3;	} 
;


AssignedIdentifier
	: DefinedValue
	| ObjectIdentifierValue
	| /*empty*/					{		$$ = nullptr;  }
;


SymbolList
	: Symbol					{	$$ = new SymbolList;	$$->push_back(SymbolPtr($1));     }
	| Symbol ',' SymbolList		{	$3->push_back(SymbolPtr($1));	$$ = $3;   }
;

Symbol
	: TYPEREFERENCE									{ $$ = new TypeReference(*$1, false); delete $1;	}
	| VALUEREFERENCE								{ $$ = new ValueReference(*$1, false); delete $1; }
	| OBJECTCLASSREFERENCE							{ $$ = new ObjectClassReference(*$1, false); delete $1;	}
	| OBJECTREFERENCE								{ $$ = new ObjectReference(*$1, false); delete $1;	}
	| OBJECTSETREFERENCE							{ $$ = new ObjectSetReference(*$1, false); delete $1;  }
	| PARAMETERIZEDTYPEREFERENCE '{' '}'			{ $$ = new TypeReference(*$1, true); delete $1;	}
	| PARAMETERIZEDVALUEREFERENCE '{' '}'			{ $$ = new ValueReference(*$1, true); delete $1;  }
	| PARAMETERIZEDOBJECTCLASSREFERENCE '{' '}'		{ $$ = new ObjectClassReference(*$1, true); delete $1;  }
	| PARAMETERIZEDOBJECTREFERENCE '{' '}'			{ $$ = new ObjectReference(*$1, true); delete $1;  }
	| PARAMETERIZEDOBJECTSETREFERENCE '{' '}'		{ $$ = new ObjectSetReference(*$1, true); delete $1; }
;

AssignmentList: Assignment 							[YYVALID;]
	| AssignmentList Assignment 					[YYVALID;]
;

Assignment
	: TypeAssignment
	| ValueAssignment
	| ValueSetTypeAssignment
	| ObjectClassAssignment	
	| ObjectAssignment
	| ObjectSetAssignment
	| ParameterizedAssignment
;

ValueSetTypeAssignment
	: TYPEREFERENCE Type		{
		$2->setName(*$1); delete $1;
		context->valueTypeContext.reset($2);
		$2->beginParseValueSet();
    }
    ASSIGNMENT ValueSet {
		$2->endParseValueSet();
		context->module->addType($5->MakeValueSetType());
		delete $5;
	}
;

TypeAssignment
	: TYPEREFERENCE ASSIGNMENT Type		{ $3->setName(*$1); delete $1; context->module->addType(TypePtr($3)); }
;

Type
	: ConstrainedType
	| ReferencedType
	| BuiltinType
;

BuiltinType
	: BitStringType
	| BooleanType
	| CharacterStringType
	| ChoiceType
//	| DateType
//	| DateTimeType
//	| DurationType
	| EmbeddedPDVType
	| EnumeratedType
	| ExternalType
//	| AnyType
	| InstanceOfType  { }
	| IntegerType
//	| IRIType
	| NullType
	| ObjectClassFieldType
	| ObjectIdentifierType
	| OctetStringType
	| RealType
//	| RelativeIRIType
	| RelativeOIDType
	| SequenceType
	| SequenceOfType
	| SetType
	| SetOfType
	| TaggedType
//	| TimeType
//	| TimeOfDayType
;


ReferencedType
	: DefinedType
	| UsefulType
	| SelectionType
	| TypeFromObject
	| ValueSetFromObjects
    {
		$$= $1->MakeValueSetType().get();
		delete $1;
    }
;


DefinedType
	: SimpleDefinedType						{ $$ = new DefinedType(*$1);		delete $1;      }
	| ParameterizedType
/*| ParameterizedValueSetType		synonym for ParameterizedType */
;


ExternalTypeReference
	: MODULEREFERENCE '.' TYPEREFERENCE	{ *$1 += *$3;		delete $3;      }
;

BitStringType
	: BIT STRING						{ $$ = new BitStringType;	}
	| BIT STRING '{' NamedBitList '}'	{ $$ = new BitStringType(*$4);delete $4;  }
;

NamedBitList
	: NamedBit							{ $$ = new NamedNumberList;	$$->push_back(NamedNumberPtr($1));  }
	| NamedBitList ',' NamedBit			{ $1->push_back(NamedNumberPtr($3)); }
;

NamedBit
	: IDENTIFIER '(' INTEGER ')'		{ $$ = new NamedNumber($1, (int)$3); }
	| IDENTIFIER '(' DefinedValue ')'	{ $$ = new NamedNumber($1, ((DefinedValue*)$3)->getReference()); delete $3; }
;

BooleanType
	: BOOLEAN_t		{	$$ = new BooleanType;	}
;

/*
TimeType 				::= TIME ;
TimeValue 				::= tstring ;
XMLTimeValue 			::= xmltstring ;
DateType 				::= DATE ;
TimeOfDayType 			::= TIME_OF_DAY ;
DateTimeType 			::= DATE_TIME ;
DurationType 			::= DURATION ;
*/


CharacterStringType
	: RestrictedCharacterStringType
	| UnrestrictedCharacterStringType
;

RestrictedCharacterStringType
	: BMPString			{	$$ = new BMPStringType;	}
	| UTF8String		{	$$ = new UTF8StringType; }
	| GeneralString		{	$$ = new GeneralStringType; }
	| GraphicString		{	$$ = new GraphicStringType; }
	| IA5String			{	$$ = new IA5StringType; }
	| ISO646String		{	$$ = new ISO646StringType; }
	| NumericString		{	$$ = new NumericStringType; }
	| PrintableString	{	$$ = new PrintableStringType;  }
	| TeletexString		{	$$ = new TeletexStringType;  }
	| T61String			{	$$ = new T61StringType; }
	| UniversalString	{	$$ = new UniversalStringType; }
	| VideotexString	{	$$ = new VideotexStringType; }
	| VisibleString		{	$$ = new VisibleStringType; }
;

UnrestrictedCharacterStringType
	: CHARACTER STRING	{	$$ = new UnrestrictedCharacterStringType; }
;

ChoiceType
	: CHOICE '{'				{	context->parsingConstructedType++;  }
    AlternativeTypeLists '}'	{	$$ = $4;   context->parsingConstructedType--; }
;

AlternativeTypeLists
	: AlternativeTypeList															{	$$ = new ChoiceType($1);	}
	| AlternativeTypeList ',' ExtensionAndException	ExtensionadditionAlternatives	{	$$ = new ChoiceType($1, true); }
//	| AlternativeTypeList ',' ExtensionAndException  ','  AlternativeTypeList		{	$$ = new ChoiceType($1, true, $5);  }
;

ExtensionadditionAlternatives 	: ',' ExtensionadditionAlternativesList | /*empty*/ ;

ExtensionadditionAlternativesList 	:
ExtensionadditionAlternative
| ExtensionadditionAlternativesList ',' ExtensionadditionAlternative
;

ExtensionadditionAlternative 	:
ExtensionadditionAlternativesGroup
| NamedType
;

ExtensionadditionAlternativesGroup 	:
"[[" VersionNumber AlternativeTypeList "]]"
;
AlternativeTypeList
	: NamedType							{ $$ = new TypesVector;	$$->push_back(TypePtr($1)); }
	| AlternativeTypeList ',' NamedType	{ $1->push_back(TypePtr($3)); }
;

NamedType
	: IDENTIFIER Type		{ $2->setName(*$1); delete $1; $$ = $2; }
/* ITU-T Rec. X.680 Appendix H.1 */
/*
	| Type					{ 
		std::cerr << StdError(Warning) << "unnamed field." << std::endl;
		std::stringstream strm;
		strm << "_unnamed" << UnnamedFieldCount++<< std::ends;
		$1->setName(strm.str());
    }
*/
/*| SelectionType    /* Unnecessary as have rule in Type for this */
;

EmbeddedPDVType
	: EMBEDDED PDV	{	$$ = new EmbeddedPDVType;	}
;

/*
Enumerations 		::=
  Enumeration
| Enumeration "," "..." ExceptionSpec
| Enumeration "," "..." ExceptionSpec "," Enumeration
;
Enumeration 		::= EnumerationItem | EnumerationItem "," Enumeration ;
EnumerationItem 	::= identifier | NamedNumber ;
EnumeratedValue 	::= identifier ;
*/
EnumeratedType
	: ENUMERATED '{' Enumerations '}'      {	$$ = $3;   }
;

Enumerations
	: Enumeration				{ $$ = new EnumeratedType(*$1, false, nullptr);	delete $1; }
	| Enumeration  ',' ELLIPSIS	{ $$ = new EnumeratedType(*$1, true, nullptr); delete $1; }
	| Enumeration  ',' ELLIPSIS ',' Enumeration { $$ = new EnumeratedType(*$1, true, $5); delete $1; }
;

Enumeration
	: EnumerationItem					{ $$ = new NamedNumberList; $$->push_back(NamedNumberPtr($1)); }
	| Enumeration ',' EnumerationItem	{ $3->setAutoNumber(*($1->back()));	$1->push_back(NamedNumberPtr($3)); $$ = $1; }
;

EnumerationItem
	: IDENTIFIER					{	$$ = new NamedNumber($1); }
	| NamedNumber
;

ExternalType
	: EXTERNAL						{	$$ = new ExternalType;    }
;

/*
AnyType
	: ANY							{	$$ = new AnyType(nullptr);    }
	| ANY DEFINED BY IDENTIFIER		{	$$ = new AnyType(*$4);	delete $4;  }
;
*/

InstanceOfType
	: INSTANCE OF_t DefinedObjectClass
;

IntegerType
	: INTEGER_t							{	$$ = new IntegerType;   }
	| INTEGER_t '{' NamedNumberList '}'	{	$$ = new IntegerType(*$3); delete $3;     }
;

NullType
	: NULL_TYPE						{	$$ = new NullType;    }
;

ObjectClassFieldType
	: SimpleObjectClassFieldType	{ $$  = $1; }
	| SimpleObjectClassFieldType '(' TableConstraint ExceptionSpec ')' {
		$1->addTableConstraint(boost::shared_ptr<TableConstraint>($3));	$$ = $1;
	}
	| SimpleObjectClassFieldType '(' ConstraintSpec ExceptionSpec ')' {
		$1->addConstraint(ConstraintPtr($3)); $$ = $1;
	}
;

SimpleObjectClassFieldType
	: DefinedObjectClass			{  context->informationFromObjectContext = $1;  } '.' FieldName {
		$$ = new ObjectClassFieldType(ObjectClassBasePtr($1), *$4); delete $4;
		context->informationFromObjectContext = nullptr;
	}
;

ObjectIdentifierType		: OBJECT IDENTIFIER_t		{ $$ = new ObjectIdentifierType;  };

OctetStringType				: OCTET STRING				{ $$ = new OctetStringType;  };

RealType					: REAL_t					{ $$ = new RealType; };

SequenceAndBrace			: SEQUENCE	{ context->parsingConstructedType++; }  '{';

SequenceType
	: SequenceAndBrace ComponentTypeLists '}'	{ $$ = $2; context->parsingConstructedType--; }
	| SequenceAndBrace  '}'						{ $$ = new SequenceType(nullptr, false, nullptr); context->parsingConstructedType--; }
	| SequenceAndBrace ExtensionAndException OptionalExtensionMarker '}' {
		$$ = new SequenceType(nullptr, true, nullptr);
		context->parsingConstructedType--;
	}
;

ExtensionAndException		: ELLIPSIS ExceptionSpec;

OptionalExtensionMarker		: ',' ELLIPSIS | /*empty*/ ;

ExceptionSpec
	: '!' ExceptionIdentification		{ $$ = $2;      }
	| /*empty*/							{ $$ = nullptr;      }
;

ExceptionIdentification
	: SignedNumber						{ $$ = new IntegerValue($1); }
	| DefinedValue
	| Type								{ context->valueTypeContext.reset($1);  $1->beginParseValue(); }
      ':' Value							{ $1->endParseValue(); $$ = $4;  }
;

ComponentTypeLists
	: ComponentTypeList {
		$$ = new SequenceType($1, false, nullptr); 
	}
	| ComponentTypeList ',' ExtensionAndException Extensionadditions OptionalExtensionMarker {
		$$ = new SequenceType($1, true, nullptr); 
	}
	| ComponentTypeList ',' ExtensionAndException Extensionadditions ExtensionEndMarker ',' ComponentTypeList {
		$$ = new SequenceType($1, true, $7); 
	}
	| ExtensionAndException Extensionadditions ExtensionEndMarker ',' ComponentTypeList	{
		$$ = new SequenceType(nullptr, true, $5); 
	}
	| ExtensionAndException Extensionadditions OptionalExtensionMarker {
		$$ = new SequenceType(nullptr, true, nullptr); 
	}
;

RootComponentTypeList
	: ComponentTypeList		
;

ExtensionEndMarker
	: ',' ELLIPSIS ;

Extensionadditions
	: ',' ExtensionadditionList 
	| /*empty*/
;

ExtensionadditionList
	: Extensionaddition 
	| ExtensionadditionList ',' Extensionaddition
;

Extensionaddition
	: ComponentType 
	| ExtensionadditionGroup
;

ExtensionadditionGroup
	: "[[" VersionNumber ComponentTypeList "]]" 
;

VersionNumber
	: /*empty*/ 
	| Number ':' 
;

ComponentTypeList
	: ComponentType								{ $$ = new TypesVector; $$->push_back(*$1); delete $1; }
	| ComponentTypeList ',' ComponentType		{ $1->push_back(*($3));	delete $3; }
;

ComponentType
	: NamedType									{ $$ = new TypePtr($1); }
	| NamedType OPTIONAL_t						{ $1->setOptional(); $$ = new TypePtr($1); }
	| NamedType									{ context->valueTypeContext.reset($1); $1->beginParseValue(); }
	  DEFAULT Value	{
		$1->setDefaultValue(ValuePtr($4));
		$$ = new TypePtr(context->valueTypeContext);
		$1->endParseValue();
    }
	| COMPONENTS OF_t Type						{ $$ = new TypePtr($3); }
;


SequenceOfType
	: SEQUENCE OF_t TypeOrNamedType				{ $$ = new SequenceOfType(TypePtr($3)); }
;

SetType
	: SetAndBrace ComponentTypeLists '}'		{ 
		$$ = new SetType(*(SequenceType*)$2); delete $2; 
		context->parsingConstructedType--;  
	}
	| SetAndBrace  '}'							{ $$ = new SetType;	context->parsingConstructedType--;   }
;

SetAndBrace
	: SET										{ context->parsingConstructedType++; }
    '{'
;

SetOfType
	: SET OF_t TypeOrNamedType					{ $$ = new SetOfType(TypePtr($3)); }
;

TypeOrNamedType	
	: Type 
	| NamedType
;

TaggedType
	: Tag Type {
		$2->setTag($1.tagClass, $1.tagNumber, context->module->getDefaultTagMode());
		$$ = $2;
    }
	| Tag IMPLICIT Type {
		$3->setTag($1.tagClass, $1.tagNumber, Tag::Implicit);
		$$ = $3;
    }
	| Tag EXPLICIT Type {
		$3->setTag($1.tagClass, $1.tagNumber, Tag::Explicit);
		$$ = $3;
    }
;

Tag
	: '[' Class ClassNumber ']'					{ $$.tagClass = (Tag::Type)$2; $$.tagNumber = (int)$3;  }
;

ClassNumber
	: INTEGER
	| DefinedValue      {
		IntegerValue* val = dynamic_cast<IntegerValue*>($1);
		if (val) {
		  $$ = *val;
		  delete $1;
		} else
		  std::cerr << StdError(Fatal) << "incorrect value type." << std::endl;
    }
;

Class
	: UNIVERSAL			{	$$ = Tag::Universal; }
	| APPLICATION		{	$$ = Tag::Application; }
	| PRIVATE			{	$$ = Tag::Private;  }
	| /*empty*/			{	$$ = Tag::ContextSpecific; }
;

SelectionType
	: IDENTIFIER '<' Type	{ $$ = new SelectionType(*$1, TypePtr($3)); delete $1; }
;

UsefulType
	: GeneralizedTime			{ $$ = new GeneralizedTimeType; }
	| UTCTime					{ $$ = new UTCTimeType; }
	| ObjectDescriptor_t		{ $$ = new ObjectDescriptorType; }
;

TypeFromObject
	: ReferencedObjectDot TYPEFIELDREFERENCE {
		  $$ = new TypeFromObject(InformationObjectPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
	}
;

ValueSetFromObjects
	: ReferencedObjectsDot FIXEDTYPEVALUEFIELDREFERENCE
   {
		  $$ = new ValueSetFromObjects(ObjectSetConstraintElementPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
   }
	| ReferencedObjectsDot FIXEDTYPEVALUESETFIELDREFERENCE
   {
		  $$ = new ValueSetFromObjects(ObjectSetConstraintElementPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
   }
	| ValueSetFromObject
;

ObjectSetFromObjects
	: ReferencedObjectsDot OBJECTFIELDREFERENCE
    {
		  $$ = new ObjectSetFromObjects(ObjectSetConstraintElementPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
		}
	| ReferencedObjectsDot OBJECTSETFIELDREFERENCE
    {
		  $$ = new ObjectSetFromObjects(ObjectSetConstraintElementPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
		}
	| ObjectSetFromObject
;


ReferencedObjects
	: DefinedObjectSet			{ $$ = $1; }
	| ObjectSetFromObjects		{ $$ = $1; }
	| ParameterizedObjectSet	{ $$ = $1; }
;

ReferencedObject
	: DefinedObject
	| ObjectFromObject
	| ParameterizedObject
;

ParameterizedObject
	: PARAMETERIZEDOBJECTREFERENCE ActualParameterList						    {  }
	| MODULEREFERENCE '.' PARAMETERIZEDOBJECTREFERENCE ActualParameterList		{  }
;


/********/
ConstrainedType
	: Type Constraint		{	$1->addConstraint(ConstraintPtr($2));   }
	| TypeWithConstraint
;

TypeWithConstraint
	: SET Constraint OF_t TypeOrNamedType			{ $$ = new SetOfType(TypePtr($4), ConstraintPtr($2)); }
	| SET SizeConstraint OF_t TypeOrNamedType		{ ConstraintElementPtr cons($2); $$ = new SetOfType(TypePtr($4), ConstraintPtr(new Constraint(cons))); }
	| SEQUENCE Constraint OF_t TypeOrNamedType		{ $$ = new SequenceOfType(TypePtr($4), ConstraintPtr($2));  }
	| SEQUENCE SizeConstraint OF_t TypeOrNamedType	{ ConstraintElementPtr cons($2); $$ = new SequenceOfType(TypePtr($4), ConstraintPtr(new Constraint(cons))); }
;

Constraint
	: '(' ConstraintSpec ExceptionSpec ')' { $$ = $2;  }
;

/*
ConstraintSpec 		::= SubtypeConstraint | GeneralConstraint ;
SubtypeConstraint 	::= ElementSetSpecs;
*/
ConstraintSpec
	: ElementSetSpecs
	| UserDefinedConstraint /* GeneralConstraint */
;

ElementSetSpecs
	: ElementSetSpec					{	$$ = new Constraint(std::auto_ptr<ConstraintElementVector>($1), false);   }
	| ElementSetSpec  ',' ELLIPSIS		{	$$ = new Constraint(std::auto_ptr<ConstraintElementVector>($1), true);    }
/*
	| ELLIPSIS ',' ElementSetSpec		{	$$ = new Constraint(std::auto_ptr<ConstraintElementVector>(), true,
												std::auto_ptr<ConstraintElementVector>($3));  }
*/
	| ElementSetSpec  ',' ELLIPSIS ',' ElementSetSpec {
		$$ = new Constraint(std::auto_ptr<ConstraintElementVector>($1),	true,
												std::auto_ptr<ConstraintElementVector>($5));
    }
;

ElementSetSpecCommaEllipsis
	: ElementSetSpec  ',' ELLIPSIS
;

ElementSetSpec
	: Unions
	| ALL Exclusions      {
		$$ = new ConstraintElementVector;
		$$->push_back(ConstraintElementPtr(
								new ConstrainAllConstraintElement(ConstraintElementPtr($2))));
	}
;

Unions
	: Intersections		{
		if ($1->size() == 1)
			$$= $1; 
		else {
			$$ = new ConstraintElementVector;
			$$->push_back(ConstraintElementPtr(new ElementListConstraintElement(
			std::auto_ptr<ConstraintElementVector>($1))));
		}
    }
	| Unions UnionMark Intersections {
		if ($3->size() == 1) {
			$$->push_back( (*$3)[0]);
			delete $3;
		} else
			$$->push_back(ConstraintElementPtr(new ElementListConstraintElement(
								std::auto_ptr<ConstraintElementVector>($3))));
	}
;

Intersections
	: IntersectionElements {
		$$ = new ConstraintElementVector;
		$$->push_back(ConstraintElementPtr($1));
    }
	| Intersections IntersectionMark IntersectionElements {
   		$$->push_back(ConstraintElementPtr($3));
    }
;

IntersectionElements
	: Elements
	| Elements Exclusions { $1->setExclusions(ConstraintElementPtr($2));  }
;

Exclusions
	: EXCEPT Elements  { $$ = $2; }
;

UnionMark
	: '|'
	| UNION
;

IntersectionMark
	: '^'
	| INTERSECTION
;

Elements
	: SubtypeElements
	| ObjectSetElements
	| '(' ElementSetSpecs ')' {
//		$$ = new ElementListConstraintElement(std::auto_ptr<ConstraintElementVector>($2));
		$$ = new NestedConstraintConstraintElement(ConstraintPtr($2));
    }
;

SubtypeElements
	: SingleValue				
	| ContainedSubtype			{ $$ = new SubTypeConstraintElement(TypePtr($1)); }
	| ValueRange
	| PermittedAlphabet
	| SizeConstraint
    | TypeConstraint
	| InnerTypeConstraints
	| PatternConstraint
	| PropertySettings
//	| DurationRange				same as Valuerange avoid 80 reduce/reduce conflict
//	| TimePointRange			same as Valuerange avoid 80 reduce/reduce conflict
//	| RecurrenceRange			same as Valuerange avoid 80 reduce/reduce conflict
;
//DurationRange 	: ValueRange ;
//TimePointRange 	: ValueRange ;
//RecurrenceRange 	: ValueRange ;

SingleValue			: Value { $$ = new SingleValueConstraintElement(ValuePtr($1)); };
ValueRange			: Lowerendpoint RANGE Upperendpoint { $$ = new ValueRangeConstraintElement(ValuePtr($1), ValuePtr($3)); };
Lowerendpoint		: LowerendValue	| LowerendValue '<';
Upperendpoint		: UpperendValue	| '<' UpperendValue		{ $$ = $2; };
LowerendValue		: Value	| MIN { $$ = new MinValue; };
UpperendValue		: Value	| MAX { $$ = new MaxValue; };
PermittedAlphabet	: FROM Constraint { $$ = new FromConstraintElement(ConstraintPtr($2)); };
SizeConstraint		: SIZE_t Constraint	{ $$ = new SizeConstraintElement(ConstraintPtr($2));  };
TypeConstraint 		: Type ;

ContainedSubtype
	: INCLUDES Type			{ $$ = $2;  }
/*| Type		 Actual grammar has INCLUDES keyword optional but this is
				 horribly ambiguous, so only support  a few specific Type
				 definitions */
;



InnerTypeConstraints
	: WITH COMPONENT Constraint {
		$$ = new WithComponentConstraintElement("", ConstraintPtr($3), WithComponentConstraintElement::Default);
      }
	| WITH COMPONENTS MultipleTypeConstraints {
		$$ = $3;
      }
;

MultipleTypeConstraints
	: '{' TypeConstraints '}'						/* FullSpecification */
      {
		$$ = new InnerTypeConstraintElement(std::auto_ptr<ConstraintElementVector>($2), false);
      }
	| '{'  ELLIPSIS ',' TypeConstraints '}'		/* PartialSpecification */
      {
		$$ = new InnerTypeConstraintElement(std::auto_ptr<ConstraintElementVector>($4), true);
      }
;

TypeConstraints
	: NamedConstraint						{ $$ = new ConstraintElementVector; $$->push_back(ConstraintElementPtr($1)); }
	| NamedConstraint ',' TypeConstraints   { $3->push_back(ConstraintElementPtr($1)); $$ = $3; }
;

NamedConstraint
	: IDENTIFIER PresenceConstraint  {
		$$ = new WithComponentConstraintElement(*$1, ConstraintPtr(), (int)$2); delete $1;
    }
	| IDENTIFIER Constraint PresenceConstraint {
		$$ = new WithComponentConstraintElement(*$1, ConstraintPtr($2), (int)$3); delete $1;
    }
;

PresenceConstraint
	: PRESENT			{	$$ = WithComponentConstraintElement::Present;     }
	| ABSENT			{	$$ = WithComponentConstraintElement::Absent;     }
	| OPTIONAL_t		{	$$ = WithComponentConstraintElement::Optional;      }
	| /*empty*/			{	$$ = WithComponentConstraintElement::Default;     }
;

/*
GeneralConstraint
	: UserDefinedConstraint
	| TableConstraint
	| ContentsConstraint
;
*/
PatternConstraint		: PATTERN Value { $$ = new PatternValueConstraintElement(ValuePtr($2)); };
PropertySettings 		: SETTINGS CSTRING	{ $$ = $2; };

UserDefinedConstraint
	: CONSTRAINED BY '{' UserDefinedConstraintParameterList '}' {
	  ConstraintElementPtr cons($4);
      $$ = new Constraint(cons);
    }
;

UserDefinedConstraintParameterList
	: /*empty*/							{ $$ = new UserDefinedConstraintElement(ActualParameterListPtr()); }
	| UserDefinedConstraintParameters	{ $$ = new UserDefinedConstraintElement(ActualParameterListPtr($1)); }
;

UserDefinedConstraintParameters
	: UserDefinedConstraintParameter ',' UserDefinedConstraintParameters	{ $3->push_back(ActualParameterPtr($1)); $$ = $3; }
	| UserDefinedConstraintParameter										{ $$ = new ActualParameterList; $$->push_back(ActualParameterPtr($1));  }
;

UserDefinedConstraintParameter
	: Governor ':' ActualParameter	{ $$ = $3; }
	| ActualParameter
;

Governor
	: Type							{ delete $1; }
	| DefinedObjectClass			{ delete $1; }

;
/*
ActualParameterList 		::= "{" ActualParameter "," + "}";
ActualParameter 			::= Type | Value | ValueSet | DefinedObjectClass | Object | ObjectSet;
*/
ActualParameterList
	: '{' ActualParameters '}'				{		$$ = $2;      }
;

ActualParameters
	: ActualParameters ',' ActualParameter	{ $1->push_back(ActualParameterPtr($3)); $$ = $1;  }
	| ActualParameter						{ $$ = new ActualParameterList;	$$->push_back(ActualParameterPtr($1));  }
;

ActualParameter
	: Type									{ $$ = new ActualTypeParameter(TypePtr($1)); }
	| Value									{ $$ = new ActualValueParameter(ValuePtr($1)); }
	| '{' DefinedType '}' /* ValueSet */    { $$ = new ActualValueSetParameter(TypePtr($2) ); }
//	| DefinedObjectClass { }
	| ObjectParameter /* Object */			{ $$ = new ActualObjectParameter(InformationObjectPtr($1)); }
	| '{' ObjectSetParameter '}' /* ObjectSet */ { $$ = new ActualObjectSetParameter(boost::shared_ptr<ObjectSetConstraintElement>($2)); }
;

ObjectParameter
	: DefinedObject
	| ParameterizedObject
;

ObjectSetParameter
	: DefinedObjectSet			{  $$ = $1; }
	| ParameterizedObjectSet	{  $$ = $1; }
;
TableConstraint
	: SimpleTableConstraint
	| ComponentRelationConstraint
;

SimpleTableConstraint
	: '{' DefinedObjectSet '}' /* '{' ObjectSet '}'*/    {
		$$ = new TableConstraint(DefinedObjectSetPtr($2));
	}
;

ComponentRelationConstraint
	: '{' DefinedObjectSet '}' '{' AtNotations '}' {
		$$ = new TableConstraint(DefinedObjectSetPtr($2), std::auto_ptr<StringList>($5)); 
	}
;

AtNotations
	: AtNotations ',' AtNotation      { $1->push_back(*$3);	  delete $3;	}
	| AtNotation				      { $$ = new StringList;  $$->push_back(*$1);  delete $1; }
;

AtNotation
	: '@' ComponentIdList		{  $$ = $2;  }
	| '@' '.' ComponentIdList	{  $3->insert(0, ".");  $$ = $3; }
;

ComponentIdList
	: ComponentIdList '.' IDENTIFIER	{  *($1) += '.' ;  *($1) += *($3);  $$ = $1;  delete $3; }
	| IDENTIFIER
;

ObjectClassAssignment
	: OBJECTCLASSREFERENCE ASSIGNMENT ObjectClass
    {
		$3->setName(*$1); delete $1;
		context->module->addObjectClass(ObjectClassBasePtr($3));
	}
;

ObjectAssignment
	: OBJECTREFERENCE DefinedObjectClass
    {
		context->informationFromObjectContext = $2;
		$2->beginParseObject();
    }
  ASSIGNMENT Object
    {
		$2->endParseObject();
		context->classStack->pop();
		$5->setName(*$1); delete $1;
		$5->setObjectClass($2);
		context->module->addInformationObject(InformationObjectPtr($5));
		context->informationFromObjectContext = nullptr;
	}
;

ObjectSetAssignment
	: OBJECTSETREFERENCE DefinedObjectClass
    {
		   $2->beginParseObjectSet();
	}
  ASSIGNMENT ObjectSet
    {
		context->module->addInformationObjectSet(InformationObjectSetPtr(
		new InformationObjectSetDefn(*$1, ObjectClassBasePtr($2), ConstraintPtr($5))));
		delete $1;
		context->classStack->pop();
	}
;


ObjectClass
	: DefinedObjectClass	{	$$ = $1;  }
	| ObjectClassDefn		{	$$ = $1;  }
/*  | ParameterizedObjectClass */
;

DefinedObjectClass
	: OBJECTCLASSREFERENCE				{ $$ = new DefinedObjectClass(*$1); delete $1; }
	| ExternalObjectClassReference		{ $$ = new DefinedObjectClass(*$1); delete $1; }
	| UsefulObjectClassReference		{ $$ = new DefinedObjectClass(*$1); delete $1; }
;

ExternalObjectClassReference
	: MODULEREFERENCE '.' OBJECTCLASSREFERENCE	{ $$ = ConcatNames($1, '.', $3); }
;

UsefulObjectClassReference
	: TYPE_IDENTIFIER					{ $$ = new std::string("TYPE-IDENTIFIER"); }
	| ABSTRACT_SYNTAX					{ $$ = new std::string("ABSTRACT-SYNTAX"); }
;

ObjectClassDefn
	: CLASS  '{'  FieldSpecs '}' WithSyntaxSpec  {
		ObjectClassDefn* ocd = new ObjectClassDefn;
		$$ = ocd;
		ocd->setFieldSpecs(std::auto_ptr<FieldSpecsList>($3));
		ocd->setWithSyntaxSpec(TokenGroupPtr($5));
		context->inWithSyntaxContext = false;
    }
;

FieldSpecs
	: FieldSpecs ',' FieldSpec			{ $1->push_back(FieldSpecPtr($3)); $$=$1; }
	| FieldSpec							{ $$ = new FieldSpecsList; $$->push_back(FieldSpecPtr($1)); }
;

FieldSpec
	: TypeFieldSpec
	| FixedTypeValueFieldSpec
	| VariableTypeValueFieldSpec
	| FixedTypeValueSetFieldSpec
	| VariableTypeValueSetFieldSpec
	| ObjectFieldSpec
	| ObjectSetFieldSpec
;

TypeFieldSpec
	: FieldReference				{ $$ = new TypeFieldSpec(*$1); delete $1; }
	| FieldReference OPTIONAL_t		{ $$ = new TypeFieldSpec(*$1, true); delete $1;  }
	| FieldReference DEFAULT Type	{ $$ = new TypeFieldSpec(*$1, false, TypePtr($3)); delete $1; }
;


FixedTypeValueFieldSpec
	: fieldreference Type  /* Unique ValueOptionalitySpec */	{ $$ = new FixedTypeValueFieldSpec(*$1, TypePtr($2)); delete $1; }
	| fieldreference Type UNIQUE		{ $$ = new FixedTypeValueFieldSpec(*$1, TypePtr($2), false, true); delete $1; }
	| fieldreference Type OPTIONAL_t	{ $$ = new FixedTypeValueFieldSpec(*$1, TypePtr($2), true);  delete $1; }
	| fieldreference Type				{ context->valueTypeContext.reset($2); $2->beginParseValue(); } DEFAULT Value	{
		  TypePtr t = context->valueTypeContext;
  		  $2->endParseValue();
		  FixedTypeValueFieldSpec* spec = new FixedTypeValueFieldSpec(*$1, t);
		  spec->setDefault(ValuePtr($5));
		  $$ = spec;
  		  delete $1;
	}
	| fieldreference Type UNIQUE OPTIONAL_t  {
		  $$ = new FixedTypeValueFieldSpec(*$1, TypePtr($2), true, true);
  		  delete $1;
	}
	| fieldreference Type UNIQUE		{ context->valueTypeContext.reset($2); $2->beginParseValue(); }
		DEFAULT Value {
		  TypePtr t = context->valueTypeContext;
		  $2->endParseValue();
		  FixedTypeValueFieldSpec* spec = new FixedTypeValueFieldSpec(*$1, t, false, true);
		  spec->setDefault(ValuePtr($6));
		  $$ = spec;
  		  delete $1;
	}
;



VariableTypeValueFieldSpec
	: fieldreference FieldReference /*  : valuefieldreference FieldName */  {
		$$ = new VariableTypeValueFieldSpec(*$1, *$2); delete $1; delete $2;
	}
	| fieldreference FieldReference OPTIONAL_t /*  | valuefieldreference FieldName OPTIONAL_t */   {
		$$ = new VariableTypeValueFieldSpec(*$1, *$2, true); delete $1; delete $2;
	}
	| fieldreference FieldReference		[ context->nullTokenContext = NULL_VALUE; ] DEFAULT Value [ context->nullTokenContext = NULL_TYPE; ]
	{ /*  | valuefieldreference FieldName DEFAULT Value */   
		VariableTypeValueFieldSpec* vtvfs = new VariableTypeValueFieldSpec(*$1, *$2, true);
		vtvfs->setDefault(ValuePtr($5)); delete $1; delete $2; 
		$$ = vtvfs;
	}
/*  | valuefieldreference FieldName DEFAULT Value */
;

FixedTypeValueSetFieldSpec
	: FieldReference Type				{ $$ = new FixedTypeValueSetFieldSpec(*$1, TypePtr($2)); delete $1;  }
	| FieldReference Type OPTIONAL_t	{ $$ = new FixedTypeValueSetFieldSpec(*$1, TypePtr($2), true); delete $1; }
	| FieldReference Type				{ context->valueTypeContext.reset($2); $2->beginParseValueSet(); }	DEFAULT ValueSet {
		TypePtr t = context->valueTypeContext;
		$2->endParseValueSet();
		FixedTypeValueSetFieldSpec* spec = new FixedTypeValueSetFieldSpec(*$1, t);
		spec->setDefault(ValueSetPtr($5));
		$$ = spec;
		delete $1;
	}
;


VariableTypeValueSetFieldSpec
	: FieldReference FieldReference /* : VALUESETFIELDREFERENCE FieldName */  {
		 $$ = new VariableTypeValueSetFieldSpec(*$1, *$2); delete $1; delete $2;
	}
	| FieldReference FieldReference OPTIONAL_t /* | VALUESETFIELDREFERENCE FieldName OPTIONAL_t */  {
		 $$ = new VariableTypeValueSetFieldSpec(*$1, *$2, true); delete $1; delete $2;
	}
	| FieldReference FieldReference DEFAULT ValueSet /* | VALUESETFIELDREFERENCE FieldName DEFAULT ValueSet */  {
		 $$ = new VariableTypeValueSetFieldSpec(*$1, *$2, true); delete $1; delete $2;
	}
/*  | FieldReference FieldName DEFAULT ValueSet */
;

ObjectFieldSpec
	: fieldreference DefinedObjectClass				{ $$ = new  ObjectFieldSpec(*$1, $2); delete $1; }
	| fieldreference DefinedObjectClass OPTIONAL_t	{ $$ = new  ObjectFieldSpec(*$1, $2, true); delete $1; }
	| fieldreference DefinedObjectClass				{ $2->beginParseObject(); }	DEFAULT Object {
		$2->endParseObject();
		context->classStack->pop();
		ObjectFieldSpec* spec = new  ObjectFieldSpec(*$1, $2); delete $1;
		spec->setDefault(InformationObjectPtr($5));
		$$ = spec;
	}
;


ObjectSetFieldSpec
	: FieldReference DefinedObjectClass {
		$$ = new  ObjectSetFieldSpec(*$1, DefinedObjectClassPtr($2)); delete $1;
	}
	| FieldReference DefinedObjectClass OPTIONAL_t {
		$$ = new  ObjectSetFieldSpec(*$1, DefinedObjectClassPtr($2), true); delete $1;
	}
	| FieldReference DefinedObjectClass { $2->beginParseObjectSet(); } DEFAULT ObjectSet  {
		ObjectSetFieldSpec* spec = new  ObjectSetFieldSpec(*$1, DefinedObjectClassPtr($2));
		delete $1;
		spec->setDefault(ConstraintPtr($5));
		$$= spec;
    	context->classStack->pop();
	}
;


WithSyntaxSpec
	: WITH SYNTAX					[ context->inWithSyntaxContext = true; ]
	 SyntaxList						[ context->inWithSyntaxContext = false;] { $$ = $4;}
	| /*empty*/						{ $$ = nullptr; }
;

SyntaxList
	: '{' TokenOrGroupSpecs '}'		{	$$ = $2;   }
	| '{' '}'						{   $$ = nullptr;	}
;

TokenOrGroupSpecs
	: TokenOrGroupSpecs TokenOrGroupSpec	{ $$ = $1;	$$->addToken(TokenOrGroupSpecPtr($2));	}
	| TokenOrGroupSpec						{ $$ = new TokenGroup;	$$->addToken(TokenOrGroupSpecPtr($1));  }
;

TokenOrGroupSpec
	: RequiredToken
	| OptionalGroup
;

OptionalGroup
	: '[' TokenOrGroupSpecs ']'		{	$2->setOptional();   $$ = $2;  }
;

RequiredToken
	: Literal						{	$$ = new Literal(*$1); delete $1;    }
	| FieldReference				{	$$ = new PrimitiveFieldName(*$1); delete $1; }
	| fieldreference				{	$$ = new PrimitiveFieldName(*$1); delete $1; }
;

Literal
	: WORD_t						{	$$ = $1;		}
	| ','							{   $$ = new std::string(",");	}
;

DefinedObject
	: OBJECTREFERENCE				{ $$ = new DefinedObject(*$1);  delete $1; }
	| ExternalObjectReference		{ $$ = new DefinedObject(*$1);  delete $1; }
;

ExternalObjectReference
	: MODULEREFERENCE '.' OBJECTREFERENCE   {  $$ = ConcatNames($1, '.', $3);		}
;

/*
ParameterizedObjectClass
	: DefinedObjectClass ActualParameterList
    { }
;
*/

DefinedObjectSet
	: OBJECTSETREFERENCE			{	$$ = new DefinedObjectSet(*$1);	delete $1; }
	| ExternalObjectSetReference	{	$$ = new DefinedObjectSet(*$1);	delete $1; }
;

ExternalObjectSetReference
	: MODULEREFERENCE '.' OBJECTSETREFERENCE	{ $$ = ConcatNames($1, '.', $3); }
;

ParameterizedObjectSet
	: PARAMETERIZEDOBJECTSETREFERENCE ActualParameterList
    { $$ = new ParameterizedObjectSet(*$1, ActualParameterListPtr($2));  delete $1;	}
	| MODULEREFERENCE '.' PARAMETERIZEDOBJECTSETREFERENCE ActualParameterList
      { std::string* str = ConcatNames($1, '.', $3);
		$$ = new ParameterizedObjectSet(*str, ActualParameterListPtr($4));
		delete str;
  }
;

FieldName
	: FieldName '.' PrimitiveFieldName	{ $$ = ConcatNames($1, '.', $3); }
	| PrimitiveFieldName
;


PrimitiveFieldName
	: TYPEFIELDREFERENCE
	| VALUEFIELDREFERENCE
	| VALUESETFIELDREFERENCE
	| OBJECTFIELDREFERENCE
	| OBJECTSETFIELDREFERENCE
;



Object
	: DefinedObject
	| ObjectDefn
	| ObjectFromObject
/*
	| ParameterizedObject
    { }
*/
;


ObjectDefn
	: DefinedSyntax    {	$$ = new DefaultObjectDefn($1->getDefaultSyntax());	delete $1; }
	| DefaultSyntax    {	$$ = new DefaultObjectDefn(std::auto_ptr<FieldSettingList>($1)); }
;

DefaultSyntax
	: OBJECT_BRACE FieldSettings '}'  {
		$$ = $2;
		if (context->inObjectSetContext)
		  context->classStack->top()->PreParseObject();
	}
;

FieldSettings
	: FieldSettings ',' PrimitiveFieldName  { context->classStack->top()->getField(*$3)->beginParseSetting($1); } Setting  {
		$$ = $1;
		context->classStack->top()->getField(*$3)->endParseSetting();
		$1->push_back(FieldSettingPtr(new FieldSetting(*$3, std::auto_ptr<Setting>($5))));
		delete $3;
	}
	| PrimitiveFieldName  {	context->classStack->top()->getField(*$1)->beginParseSetting(nullptr); } Setting  {
		$$ = new FieldSettingList;
		context->classStack->top()->getField(*$1)->endParseSetting();
		$$->push_back(FieldSettingPtr(new FieldSetting(*$1, std::auto_ptr<Setting>($3))));
		delete $1;
	}
;


DefinedSyntax
	: OBJECT_BRACE DefinedSyntaxTokens '}'
	{
		$$ = $2;
		$$->ResetTokenGroup();
		if (context->inObjectSetContext)
			context->classStack->top()->PreParseObject();
	}
;

DefinedSyntaxTokens
	: DefinedSyntaxTokens DefinedSyntaxToken	{	$$ = $1; $$->addToken($2); }
	| /*empty*/			{	$$ = new DefaultSyntaxBuilder(context->classStack->top()->getWithSyntax()); 	}
;

DefinedSyntaxToken
	: Literal			{	$$ = new LiteralToken(*$1); delete $1;  }
	| Setting			{	$$ = new SettingToken(std::auto_ptr<Setting>($1));  }
;

Setting
	: Type				{	$$ = new TypeSetting(TypePtr($1)); }
	| Value				{
							ValueBase* vb = $1;
							TypeBase*  tb = context->valueTypeContext.get();

							if (context->valueTypeContext.get() == nullptr)
								  std::cerr << StdError(Fatal) << "Parsing Error\n";
							$$ = new ValueSetting(context->valueTypeContext,ValuePtr($1));
	}
	| ValueSet		   {	$$ = new ValueSetSetting(ValueSetPtr($1)); }
	| Object		   {	$$ = new ObjectSetting(InformationObjectPtr($1),context->classStack->top()); }
	| ObjectSet		   {    $$ = new ObjectSetSetting(ConstraintPtr($1), context->classStack->top());
							context->classStack->pop();	
  }
;


ObjectSet
	: OBJECTSET_BRACE ObjectSetSpec '}'  {	$$ = $2;context->classStack->top()->endParseObjectSet();  }
;

ObjectSetSpec
	: ElementSetSpecs
	| ELLIPSIS				{	$$ = new Constraint(std::auto_ptr<ConstraintElementVector>(), true);	}
;


ObjectSetElements
	: Object					{	$$ = new SingleObjectConstraintElement(InformationObjectPtr($1));  }
	| DefinedObjectSet		{	$$ = $1;  }
	| ObjectSetFromObjects    {	$$ = $1;  }
	| ParameterizedObjectSet  {	$$ = $1;  }
;

/*!!!
ObjectSetFromObjects
	: ReferencedObjectsDot FieldName
;
*/

ReferencedObjectsDot
	: ReferencedObjects		{ context->informationFromObjectContext = $1->getObjectClass();  }
  '.'						{  $$ = $1; }
;

ReferencedObjectDot
	: ReferencedObject	    {  context->informationFromObjectContext = $1->getObjectClass();  }
  '.'					    { $$ = $1;	}
;

ParameterizedAssignment
	: ParameterizedTypeAssignment
	| ParameterizedValueAssignment
	| ParameterizedValueSetTypeAssignment
/*  | ParameterizedObjectClassAssignment */
	| ParameterizedObjectAssignment
	| ParameterizedObjectSetAssignment
;

ParameterizedTypeAssignment
	: PARAMETERIZEDTYPEREFERENCE ParameterList
      {
		context->dummyParameters = $2;
      }
    ASSIGNMENT Type
      {
		context->dummyParameters = nullptr;
		$5->setName(*$1); delete $1;
		$5->setParameters(*$2); delete $2;
		context->module->addType(TypePtr($5));
      }
;

ParameterizedValueAssignment
	: PARAMETERIZEDVALUEREFERENCE ParameterList Type	{ context->dummyParameters = $2; }
		ASSIGNMENT Value								{ context->dummyParameters = nullptr; }
;

ParameterizedValueSetTypeAssignment
	: PARAMETERIZEDTYPEREFERENCE ParameterList Type { context->dummyParameters = $2; }
		ASSIGNMENT ValueSet							{ context->dummyParameters = nullptr; }
;

/*
ParameterizedObjectClassAssignment
	: PARAMETERIZEDOBJECTCLASSREFERENCE ParameterList ASSIGNMENT ObjectClass
    { }
;
*/

ParameterizedObjectAssignment
	: PARAMETERIZEDOBJECTREFERENCE ParameterList DefinedObjectClass
      {
		context->dummyParameters = $2;
		$3->beginParseObject();
      }
    ASSIGNMENT Object
      {
		$3->endParseObject();
		context->classStack->pop();
		context->dummyParameters = nullptr;
		$6->setName(*$1); delete $1;
		$6->setObjectClass($3);
		$6->setParameters(std::auto_ptr<ParameterList>($2));
		context->module->addInformationObject(InformationObjectPtr($6));
	}
;

ParameterizedObjectSetAssignment
	: PARAMETERIZEDOBJECTSETREFERENCE ParameterList DefinedObjectClass
      {
		context->dummyParameters = $2;
		$3->beginParseObjectSet();
      }
    ASSIGNMENT ObjectSet
      {
		context->dummyParameters = nullptr;
		context->module->addInformationObjectSet(InformationObjectSetPtr(
				new InformationObjectSetDefn(*$1, ObjectClassBasePtr($3),
				                            ConstraintPtr($6), ParameterListPtr($2))));
		delete $1;
		context->classStack->pop();
		  }
;

ParameterList
	: '{' Parameters '}'				{	$$ = $2;      }
;

Parameters
	: Parameters ',' Parameter			{	$$ = $1;$$->Append(ParameterPtr($3));   }
	| Parameter							{	$$ = new ParameterList;	$$->Append(ParameterPtr($1));  }
;

Parameter
	: Type ':' Reference				{ $$ = new ValueParameter(TypePtr($1),*$3); delete $1;  }
	| DefinedObjectClass ':' Reference	{ $$ = new ObjectParameter(DefinedObjectClassPtr($1),*$3); delete $3; }
	| Reference							{ $$ = new Parameter(*$1); delete $1; }
;

ParameterizedType
	: PARAMETERIZEDTYPEREFERENCE ActualParameterList {
		$$ = new ParameterizedType(*$1, *$2);
		delete $1; delete $2;
    }
	| MODULEREFERENCE '.' PARAMETERIZEDTYPEREFERENCE ActualParameterList {
		std::string* str = ConcatNames($1, '.', $3);
		$$ = new ParameterizedType(*str,*$4);
		delete str; delete $4;
	}
;

SimpleDefinedType
	: TYPEREFERENCE
	| ExternalTypeReference
;

/********/

ValueAssignment
	: VALUEREFERENCE Type		{ context->valueTypeContext.reset($2); $2->beginParseValue(); }
		ASSIGNMENT Value		{ $2->endParseValue(); $5->setValueName(*$1); delete $1; context->module->addValue(ValuePtr($5)); }
;


Value
	: BuiltinValue
	| ReferencedValue
;


BuiltinValue
	: BitStringValue
	| BooleanValue
	| CharacterStringValue
	| ChoiceValue
//	| EmbeddedPDVValue  synonym to SequenceValue
//	| EnumeratedValue   synonym to IDENTIFIER
//	| ExternalValue     synonym to SequenceValue
//	| InstanceOfValue   synonym to Value
	| SignedNumber      /* IntegerValue */      { $$ = new IntegerValue($1); }
//	| IRIValue
	| NullValue
	| ObjectIdentifierValue
	| OctetStringValue
	| RealValue
//	| RelativeIRIValue
//	| RelativeOIDValue		synonym of ObjectIdentifierValue
	| SequenceValue
//	| SequenceOfValue
//	| setValue				synonym to SequenceValue
//	| setOfValue		    synonym to SequenceOfValue
//	| PrefixedValue
//	| TimeValue
;


DefinedValue
	: VALUEREFERENCE			{ $$ = new DefinedValue(*$1); delete $1; }
	| ExternalValueReference	{ $$ = new DefinedValue(*$1); delete $1; }
//| ParameterizedValue
;

ExternalValueReference
	: MODULEREFERENCE '.' VALUEREFERENCE      {*$1 += *$3;	delete $3;     }
;

ObjectIdentifierValue
	: OID_BRACE [context->inOIDContext = TRUE; context->inOIDLiteral = TRUE;]	ObjIdComponentList 	'}'[
		context->inOIDContext = FALSE; context->inOIDLiteral = FALSE; ]
	{	$$ = new ObjectIdentifierValue(*$3); delete $3;	}
/*!!!
	| '{' DefinedValue_OID ObjIdComponentList '}' { $$ = new ObjectIdentifierValue($2);  }
*/
;


ObjIdComponentList
	: ObjIdComponent					{ $$ = new ObjIdComponentList; $$->push_back(*$1);	delete $1;   }
	| ObjIdComponentList ObjIdComponent { $1->push_back(*$2);	$$ = $1; delete $2; }
//	| ObjIdComponent ObjIdComponentList { ObjIdComponentList::const_iterator oicl = $2->begin();$2->emplace(oicl, *$1);$$ = $2;}
;
  
ObjIdComponent
	: OID_IDENTIFIER NumberFormOptional	{ if ($2) $$ = new ObjIdComponent(*$1, *$2); else $$ = new ObjIdComponent(*$1);}
	| OID_INTEGER						{ $$ = new ObjIdComponent($1); }
;
NumberFormOptional
	: /*empty*/							{  $$ = nullptr; }
	| '(' NumberForm ')'				{  $$ = $2; }
;
NumberForm
	: OID_INTEGER						{ $$ = new NumberForm($1);  }
	| ExternalValueReference
	| VALUEREFERENCE
;

RelativeOIDType							: RELATIVE_OID { $$ = new RelativeOIDType;  };

RelativeOIDValue
	: ObjectIdentifierValue
	/*
	: OID_BRACE { context->inOIDContext = TRUE; context->inOIDLiteral = TRUE; }	ObjIdComponentList 	'}' { 
		context->inOIDContext = FALSE; context->inOIDLiteral = FALSE;
		$$ = new RelativeOIDTypeValue(*$3); delete $3;
	}
	*/
;

/*
RelativeOIDValue 					: '{' RelativeOIDComponentsList '}' ;
RelativeOIDComponentsList 			: RelativeOIDComponents | RelativeOIDComponents RelativeOIDComponentsList ;
RelativeOIDComponents 				: NumberForm | NameAndNumberForm | DefinedValue ;
*/

OctetStringValue
	: BSTRING								{ $$ = new OctetStringValue(*$1); delete $1;      }
	| HSTRING								{ $$ = new OctetStringValue(*$1); delete $1;      }
;

BitStringValue
	: BS_BSTRING							{ $$ = new BitStringValue(*$1); delete $1; }
	| BS_HSTRING							{ $$ = new BitStringValue(*$1); delete $1; }
	| '{' BitIdentifierList '}'				{ $$ = new BitStringValue($2); }
//	| "{" "}"								avoid 81 reduce/reduce conflits
	| CONTAINING Value
;

BitIdentifierList
	// FIXME initialy, there was only BIT_IDENTIFIER
	: IDENTIFIER							{ $$ = new StringList;	$$->push_back(*$1);	delete $1; } 
	| BIT_IDENTIFIER						{ $$ = new StringList;	$$->push_back(*$1);	delete $1; }
	| BitIdentifierList ',' IDENTIFIER		{ $1->push_back(*$3); delete $3; }
	| BitIdentifierList ',' BIT_IDENTIFIER	{ $1->push_back(*$3); delete $3; }
;

BooleanValue
	: TRUE_t								{ $$ = new BooleanValue(true); }
	| FALSE_t								{ $$ = new BooleanValue(false);  }
;

CharacterStringValue
	: RestrictedCharacterStringValue
/*!!!
	| UnrestrictedCharacterStringValue
*/
;

RestrictedCharacterStringValue
	: CSTRING						{ $$ = new CharacterStringValue(*$1); delete $1; }
	| CharacterStringList
	| Quadruple
	| Tuple
;

CharacterStringList
	: '{' CharSyms '}'				{ $$ = new CharacterStringValue(*$2); delete $2; }
;

CharSyms
	: CharsDefn						{ $$ = new StringList; $$->push_back(*$1);	delete $1; }
	| CharSyms ',' CharsDefn		{ $1->push_back(*$3); delete $3; }
;

CharsDefn
	: CSTRING
	| DefinedValue {
		std::cerr << StdError(Warning) << "DefinedValue in string unsupported" << *$1 << std::endl;
		$$ = new std::string(((DefinedValue*)($1))->getReference());
    }
;

Quadruple
	:  '{'  INTEGER  ','  INTEGER  ','  INTEGER  ','  INTEGER '}' {
		if ($2 != 0 || $4 != 0 || $6 > 255 || $8 > 255)
		  std::cerr << StdError(Warning) << "Illegal value in Character Quadruple" << std::endl;
		$$ = new CharacterValue((unsigned char)$2, (unsigned char)$4, (unsigned char)$6, (unsigned char)$8);
      }
;

Tuple
	:  '{' INTEGER ',' INTEGER '}' {
		if ($2 > 255 || $4 > 255)
		  std::cerr << StdError(Warning) << "Illegal value in Character Tuple" << std::endl;
		$$ = new CharacterValue((unsigned char)$2, (unsigned char)$4);
      }
;


ChoiceValue
	: IDENTIFIER ':' Value  {	$$ = new ChoiceValue(context->valueTypeContext, *$1, ValuePtr($3)); delete $1;  }
;


NullValue
	: NULL_VALUE { $$ = new NullValue; }
;


RealValue
	: NumericRealValue
	| SpecialRealValue
;

NumericRealValue
	:  '0'		{ $$ = new RealValue(0);  }
	| REAL		{ $$ = new RealValue(0);  /*FIXME*/}
//	| SequenceValue avoid reduce/reduce conflict
;

SpecialRealValue
	: PLUS_INFINITY		{ $$ = new RealValue(0); }
    | MINUS_INFINITY    { $$ = new RealValue(0); }
	| NOT_A_NUMBER      { $$ = new RealValue(0); }
;

SequenceValue
	: '{' ComponentValueList '}'	{ $$ = new SequenceValue($2); }
	| '{'  '}'						{ $$ = new SequenceValue; }
;

ComponentValueList
	: NamedValue							{ $$ = new ValuesList; $$->push_back(ValuePtr($1)); }
	| ComponentValueList ',' NamedValue		{ $1->push_back(ValuePtr($3)); }
;

NamedValue
	: IDENTIFIER Value	{ $2->setValueName(*$1); delete $1;		$$ = $2; }
;


/*!!!!
SequenceOfValue
	: '{' ValueList '}'		{ $$ = nullptr; }
	| '{'  '}'			    { $$ = nullptr; }
;

ValueList
	: Value				    { }
	| ValueList ',' Value   { }
;
*/


/*!!!
ObjectClassFieldValue
	: OpenTypeFieldVal
	| Value
;

OpenTypeFieldVal
	: Type ':' Value
;
*/


ReferencedValue
	: DefinedValue
	| ValueFromObject
;
	
ValueFromObject
	: ReferencedObjectDot VALUEFIELDREFERENCE {
		  ValueSetting* setting = (ValueSetting*) $1->getSetting(*$2);
		  $$ = new DefinedValue(setting->getValue());
		  delete $1;
		  delete $2;
		  context->informationFromObjectContext = nullptr;
	}
;

VALUEFIELDREFERENCE
	: FIXEDTYPEVALUEFIELDREFERENCE
	| VARIABLETYPEVALUEFIELDREFERENCE
;

ValueSetFromObject
 : ReferencedObjectDot VALUESETFIELDREFERENCE
   {
		  $$ = new ValueSetFromObject(InformationObjectPtr($1), *$2); delete $2;
      context->informationFromObjectContext = nullptr;
   }
;

VALUESETFIELDREFERENCE
	: FIXEDTYPEVALUESETFIELDREFERENCE
	| VARIABLETYPEVALUESETFIELDREFERENCE
;

ObjectFromObject
	: ReferencedObjectDot OBJECTFIELDREFERENCE
    {
		  $$ = new ObjectFromObject(InformationObjectPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
    }
;

ObjectSetFromObject
	: ReferencedObjectDot OBJECTSETFIELDREFERENCE
    {
		  $$ = new ObjectSetFromObject(InformationObjectPtr($1), *$2); delete $2;
		  context->informationFromObjectContext = nullptr;
    }
;

/*
ParameterizedValue
	: PARAMETERIZEDVALUEREFERENCE ActualParameterList
    { }
	| MODULEREFERENCE '.' PARAMETERIZEDVALUEREFERENCE ActualParameterList
    { }
;
*/

SimpleDefinedValue
	: VALUEREFERENCE
	| ExternalValueReference
;



ValueSet
	: VALUESET_BRACE ElementSetSpecs '}' {
		if (context->valueTypeContext.get() == nullptr)
			std::cerr << StdError(Warning) << "";
	// $$ = new ValueSetDefn(TypePtr(new DefinedType(context->valueTypeContext)), ConstraintPtr($2));
		$$ = new ValueSetDefn(context->valueTypeContext, ConstraintPtr($2));
	}
;



MacroDefinition
	: TYPEREFERENCE MACRO ASSIGNMENT MacroSubstance {
		std::cerr << StdError(Warning) << "MACRO unsupported" << std::endl;
      }
;

MacroSubstance
	: BEGIN_t							{		context->inMacroContext = true;      }
    MacroBody END						{			context->inMacroContext = false;      }
	| TYPEREFERENCE						{}
	| TYPEREFERENCE '.' TYPEREFERENCE	{}
;

MacroBody
	: TypeProduction ValueProduction /*SupportingProductions*/
;

TypeProduction
	: TYPE_t NOTATION ASSIGNMENT MacroAlternativeList
;

ValueProduction
	: VALUE NOTATION ASSIGNMENT MacroAlternativeList
;


/*
SupportingProductions
	: ProductionList
	| /*empty*//*
;

ProductionList
	: Production
	| ProductionList Production
;

Production
	: TYPEREFERENCE ASSIGNMENT MacroAlternativeList

;
*/

MacroAlternativeList
	: MacroAlternative
	| MacroAlternative '|' MacroAlternativeList
;

MacroAlternative
	: SymbolElement
	| SymbolElement MacroAlternative
;

SymbolElement
	: SymbolDefn
	| EmbeddedDefinitions
;

SymbolDefn
	: CSTRING						{}
	| TYPEREFERENCE				{}
	| TYPEREFERENCE ASSIGNMENT    {}
;

EmbeddedDefinitions
	: '<' EmbeddedDefinitionList '>'
;

EmbeddedDefinitionList
	: EmbeddedDefinition
	| EmbeddedDefinitionList EmbeddedDefinition
;

EmbeddedDefinition
	: LocalTypeAssignment
	| LocalValueAssignment
;

LocalTypeAssignment
	: TYPEREFERENCE ASSIGNMENT Type
      {}
;

LocalValueAssignment
	: IDENTIFIER Type ASSIGNMENT Value
      {}
;


/********/

/********/

/*!!! Not actually referenced by any other part of grammar
AbsoluteReference
	: '@' GlobalModuleReference '.' ItemSpec
;

ItemSpec
	: TYPEREFERENCE
	|  ItemId '.' ComponentId
;

ItemId
	: ItemSpec
;

ComponentId
	: IDENTIFIER
	| INTEGER
	| '*'
;
*/


Reference
	: TYPEREFERENCE
	| VALUEREFERENCE
	| OBJECTCLASSREFERENCE
	| OBJECTREFERENCE
	| OBJECTSETREFERENCE
	| PARAMETERIZEDTYPEREFERENCE
	| PARAMETERIZEDVALUEREFERENCE
	| PARAMETERIZEDOBJECTCLASSREFERENCE
	| PARAMETERIZEDOBJECTREFERENCE
	| PARAMETERIZEDOBJECTSETREFERENCE
	| IDENTIFIER
;

NamedNumberList
	: NamedNumber						{ $$ = new NamedNumberList;$$->push_back(NamedNumberPtr($1)); }
	| NamedNumberList ',' NamedNumber	{ $1->push_back(NamedNumberPtr($3)); }
;

NamedNumber
	: IDENTIFIER '(' SignedNumber ')'	{ $$ = new NamedNumber($1, (int)$3);      }
	| IDENTIFIER '(' DefinedValue ')'	{ $$ = new NamedNumber($1, ((DefinedValue*)$3)->getReference());		delete $3;      }
;

SignedNumber
	:  INTEGER
	| '-' INTEGER						{ $$ = -$2; }
;

Number
	: INTEGER
;

%%

int YYLEX_DECL();
int YYPARSE_DECL();
void YYERROR_DECL();

static char vchar[256];
static const char* value(int yychar, YYSTYPE yylval) {
	if (YYTRANSLATE(yychar) != YYUNDFTOKEN );


	switch(yychar) {
		/*
     case ABSENT = 293,
     case ABSTRACT_SYNTAX = 294,
     case ALL = 295,
     case ANY = 296,
     case APPLICATION = 297,
     case ASSIGNMENT = 298,
     case AUTOMATIC = 299,
     case BEGIN_t = 300,
     case BIT = 301,
     case BMPString = 302,
     case BOOLEAN_t = 303,
     case BY = 304,
     case CHARACTER = 305,
     case CHOICE = 306,
     CLASS = 307,
     case COMPONENT = 308,
     case COMPONENTS = 309,
     case CONSTRAINED = 310,
     case CONTAINING = 311,
     case DEFAULT = 312,
     case DEFINED = 313,
     case DEFINITIONS = 314,
     case ELLIPSIS = 315,
     case EMBEDDED = 316,
     case END = 317,
     case ENUMERATED = 318,
     case EXCEPT = 319,
     case EXPLICIT = 320,
     case EXPORTS = 321,
     case EXTENSIBILITY = 322,
     case EXTERNAL = 323,
     case FALSE_t = 324,
     case FROM = 325,
     case GeneralString = 326,
     case GeneralizedTime = 327,
     case GraphicString = 328,
     case IA5String = 329,
     case IDENTIFIER_t = 330,
     case IMPLICIT = 331,
     case IMPLIED = 332,
     case IMPORTS = 333,
     case INCLUDES = 334,
     case INSTANCE = 335,
     case INSTRUCTIONS = 336,
     case INTEGER_t = 337,
     case INTERSECTION = 338,
     case ISO646String = 339,
     case MACRO = 340,
     case MAX = 341,
     case MIN = 342,
     case MINUS_INFINITY = 343,
     case NOTATION = 344,
     case NOT_A_NUMBER = 345,
     case NULL_TYPE = 346,
     case NULL_VALUE = 347,
     case NumericString = 348,
     case OBJECT = 349,
     case OCTET = 350,
     case OID_IRI = 351,
     case OF_t = 352,
     case OPTIONAL_t = 353,
     case PATTERN = 354,
     case PDV = 355,
     case PLUS_INFINITY = 356,
     case PRESENT = 357,
     case PRIVATE = 358,
     case PrintableString = 359,
     case RANGE = 360,
     case REAL_t = 361,
     case RELATIVE_OID = 362,
     case RELATIVE_OID_IRI = 363,
     case SEQUENCE = 364,
     case SET = 365,
     case SETTINGS = 366,
     case SIZE_t = 367,
     case STRING = 368,
     case SYNTAX = 369,
     case T61String = 370,
     case TAGS = 371,
     case TRUE_t = 372,
     case TYPE_IDENTIFIER = 373,
     case TYPE_t = 374,
     case TeletexString = 375,
     case UNION = 376,
     case UNIQUE = 377,
     case UNIVERSAL = 378,
     case UTCTime = 379,
     case UTF8String = 380,
     case UniversalString = 381,
     case VALUE = 382,
     case VideotexString = 383,
     case VisibleString = 384,
     case WITH = 385,
     case ObjectDescriptor_t = 386,
     case WORD_t = 387,
	 */
// <sval>
        case CSTRING:
        case BSTRING:
        case HSTRING:
        case BS_BSTRING:
        case BS_HSTRING:
        case IDENTIFIER:
        case BIT_IDENTIFIER:
        case OID_IDENTIFIER:
        case IMPORT_IDENTIFIER:
        case TYPEREFERENCE:
        case MODULEREFERENCE:
        case OBJECTCLASSREFERENCE:
        case VALUEREFERENCE:
	    case fieldreference:		//fieldreferece set by main does not set yylval.sval
		case FieldReference:		//FieldReference set by main does not set yylval.sval
//     case TYPEFIELDREFERENCE:
//      case VALUEFIELDREFERENCE:
//        case FIXEDTYPEVALUEFIELDREFERENCE:
        case VARIABLETYPEVALUEFIELDREFERENCE:
//      case VALUESETFIELDREFERENCE:
        case FIXEDTYPEVALUESETFIELDREFERENCE:
        case VARIABLETYPEVALUESETFIELDREFERENCE:
        case OBJECTFIELDREFERENCE:
        case OBJECTSETFIELDREFERENCE:
        case OBJECTREFERENCE:
        case OBJECTSETREFERENCE:
        case PARAMETERIZEDTYPEREFERENCE:
        case PARAMETERIZEDOBJECTCLASSREFERENCE:
        case PARAMETERIZEDVALUEREFERENCE:
        case PARAMETERIZEDOBJECTREFERENCE:
        case PARAMETERIZEDOBJECTSETREFERENCE:
        case WORD_t:
			if (yylval.sval)
				strcpy(vchar, yylval.sval->c_str()); 
			break;

// <ival>
		case INTEGER:
		case OID_INTEGER:
			sprintf(vchar, "%lld", yylval.ival); 
			break;
		default:
			*vchar = 0;
	}
	return vchar;
}
