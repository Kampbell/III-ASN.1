//
// reliable_transfer_apdu.h
//
// Code automatically generated by asnparser.
//

#ifndef __RELIABLE_TRANSFER_APDU_H
#define __RELIABLE_TRANSFER_APDU_H

#include "asn1.h"

#include "remote_operations_information_objects.h"



#ifndef ACSE_1_DEFINED
#define ACSE_1_DEFINED

#include "Platform.h"

#if defined(_WIN32)
	#include "Platform_WIN32.h"
#elif defined(__VMS)
	#include "Platform_VMS.h"
#elif defined(ALS_VXWORKS)
	#include "Platform_VX.h"
#elif defined(ALS_OS_FAMILY_UNIX)
	#include "Platform_POSIX.h"
#endif

//
// Ensure that ACSE_1_DLL is default unless ACSE_1_STATIC is defined
//
#if defined(_WIN32) && defined(_DLL)
	#if !defined(ACSE_1_DLL) && !defined(ACSE_1_STATIC)
		#define ACSE_1_DLL
	#endif
#endif

#if defined(_MSC_VER)
	#if defined(ACSE_1_DLL)
		#if defined(_DEBUG)
			#define ACSE_1_LIB_SUFFIX "d.lib"
		#else
			#define ACSE_1_LIB_SUFFIX ".lib"
		#endif
	#elif defined(_DLL)
		#if defined(_DEBUG)
			#define ACSE_1_LIB_SUFFIX "mdd.lib"
		#else
			#define ACSE_1_LIB_SUFFIX "md.lib"
		#endif
	#else
		#if defined(_DEBUG)
			#define ACSE_1_LIB_SUFFIX "mtd.lib"
		#else
			#define ACSE_1_LIB_SUFFIX "mt.lib"
		#endif
	#endif
#endif

//
// The following block is the standard way of creating macros which make exporting
// from a DLL simpler. All files within this DLL are compiled with the ACSE_1_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see
// ACSE_1_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
//
#if defined(_WIN32) && defined(ACSE_1_DLL)
	#if defined(ACSE_1_EXPORTS)
		#define ACSE_1_API __declspec(dllexport)
	#else
		#define ACSE_1_API __declspec(dllimport)
	#endif
#endif

#if !defined(ACSE_1_API)
	#define ACSE_1_API
#endif

//
// Automatically link ACSE_1 library.
//
#if defined(_MSC_VER)
	#if !defined(ACSE_1_NO_AUTOMATIC_LIBS) && !defined(ACSE_1_EXPORTS)
		#pragma comment(lib, "ACSE_1" ACSE_1_LIB_SUFFIX)
	#endif
#endif
#endif

namespace Reliable_Transfer_APDU {

typedef ASN1::INTEGER RTTPapdu;

typedef ASN1::OCTET_STRING RTTRapdu;

//
// RefuseReason
//

class ACSE_1_API RefuseReason : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RefuseReason(const void* info) : Inherited(info) {}
public:
    RefuseReason(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        rtsBusy,
        cannotRecover,
        validationFailure,
        unacceptableDialogueMode
    };

    bool is_rtsBusy() const { return value == rtsBusy; }
    void set_rtsBusy() { value = rtsBusy; }

    bool is_cannotRecover() const { return value == cannotRecover; }
    void set_cannotRecover() { value = cannotRecover; }

    bool is_validationFailure() const { return value == validationFailure; }
    void set_validationFailure() { value = validationFailure; }

    bool is_unacceptableDialogueMode() const { return value == unacceptableDialogueMode; }
    void set_unacceptableDialogueMode() { value = unacceptableDialogueMode; }

    RefuseReason(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    RefuseReason & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    RefuseReason * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[4];
}; // end class RefuseReason

//
// CallingSSuserReference
//

class ACSE_1_API CallingSSuserReference : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CallingSSuserReference(const void* info) : Inherited(info) {}
public:
    CallingSSuserReference() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      t61String0 = 0,
      octetString1 = 1
    };

    class t61String
    {
    public:
        enum Id { eid = 0 };
        typedef ASN1::T61String value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class t61String

    t61String::const_reference get_t61String () const;
    t61String::reference ref_t61String ();
    t61String::reference select_t61String ();
    t61String::reference select_t61String (const ASN1_STD string& v);
    bool t61String_isSelected() const;

    CallingSSuserReference(t61String::Id id, const ASN1_STD string& v);

    class octetString
    {
    public:
        enum Id { eid = 1 };
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class octetString

    octetString::const_reference get_octetString () const;
    octetString::reference ref_octetString ();
    octetString::reference select_octetString ();
    octetString::reference select_octetString (const ASN1_STD vector<char>& v);
    bool octetString_isSelected() const;

    CallingSSuserReference(octetString::Id id, const ASN1_STD vector<char>& v);
    CallingSSuserReference(const CallingSSuserReference & that)     : Inherited(that) {}

    CallingSSuserReference & operator=(const CallingSSuserReference & that)
    { Inherited::operator=(that); return *this; }

    void swap(CallingSSuserReference & that) { Inherited::swap(that); }

    CallingSSuserReference * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[2];
    static unsigned selectionTags[2];
    static const char* selectionNames[2];
}; // end class CallingSSuserReference

typedef ASN1::UTCTime CommonReference;

typedef ASN1::T61String AdditionalReferenceInformation;

//
// AbortReason
//

class ACSE_1_API AbortReason : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    AbortReason(const void* info) : Inherited(info) {}
public:
    AbortReason(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        localSystemProblem,
        invalidParameter,
        unrecognizedActivity,
        temporaryProblem,
        protocolError,
        permanentProblem,
        userError,
        transferCompleted
    };

    bool is_localSystemProblem() const { return value == localSystemProblem; }
    void set_localSystemProblem() { value = localSystemProblem; }

    bool is_invalidParameter() const { return value == invalidParameter; }
    void set_invalidParameter() { value = invalidParameter; }

    bool is_unrecognizedActivity() const { return value == unrecognizedActivity; }
    void set_unrecognizedActivity() { value = unrecognizedActivity; }

    bool is_temporaryProblem() const { return value == temporaryProblem; }
    void set_temporaryProblem() { value = temporaryProblem; }

    bool is_protocolError() const { return value == protocolError; }
    void set_protocolError() { value = protocolError; }

    bool is_permanentProblem() const { return value == permanentProblem; }
    void set_permanentProblem() { value = permanentProblem; }

    bool is_userError() const { return value == userError; }
    void set_userError() { value = userError; }

    bool is_transferCompleted() const { return value == transferCompleted; }
    void set_transferCompleted() { value = transferCompleted; }

    AbortReason(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    AbortReason & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    AbortReason * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[8];
}; // end class AbortReason

//
// RTORJapdu
//

class ACSE_1_API RTORJapdu : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RTORJapdu(const void* info) : Inherited(info) {}
public:
    RTORJapdu() : Inherited(&theInfo) {}
    RTORJapdu(const RTORJapdu & that) : Inherited(that) {}

    RTORJapdu& operator=(const RTORJapdu& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_refuseReason,
      e_userDataRJ
    };

    class refuseReason
    {
    public:
        typedef RefuseReason value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class refuseReason

    refuseReason::const_reference get_refuseReason () const;
    refuseReason::reference ref_refuseReason ();
    refuseReason::reference set_refuseReason ();
    refuseReason::reference set_refuseReason (refuseReason::value_type::int_type v);
    void omit_refuseReason ();
    bool refuseReason_isPresent () const;

    class userDataRJ
    {
    public:
        typedef ASN1::OpenData value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class userDataRJ

    userDataRJ::const_reference get_userDataRJ () const;
    userDataRJ::reference ref_userDataRJ ();
    userDataRJ::reference set_userDataRJ ();
    userDataRJ::reference set_userDataRJ (userDataRJ::const_reference v);
    void omit_userDataRJ ();
    bool userDataRJ_isPresent () const;
    void swap(RTORJapdu& that);
    RTORJapdu * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static unsigned fieldTags[2];
    static const char* fieldNames[2];
}; // end class RTORJapdu

//
// RTABapdu
//

class ACSE_1_API RTABapdu : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RTABapdu(const void* info) : Inherited(info) {}
public:
    RTABapdu() : Inherited(&theInfo) {}
    RTABapdu(const RTABapdu & that) : Inherited(that) {}

    RTABapdu& operator=(const RTABapdu& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_abortReason,
      e_reflectedParameter,
      e_userdataAB
    };

    class abortReason
    {
    public:
        typedef AbortReason value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class abortReason

    abortReason::const_reference get_abortReason () const;
    abortReason::reference ref_abortReason ();
    abortReason::reference set_abortReason ();
    abortReason::reference set_abortReason (abortReason::value_type::int_type v);
    void omit_abortReason ();
    bool abortReason_isPresent () const;

    class reflectedParameter
    {
    public:
        typedef ASN1::BIT_STRING value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class reflectedParameter

    reflectedParameter::const_reference get_reflectedParameter () const;
    reflectedParameter::reference ref_reflectedParameter ();
    reflectedParameter::reference set_reflectedParameter ();
    reflectedParameter::reference set_reflectedParameter (reflectedParameter::const_reference v);
    void omit_reflectedParameter ();
    bool reflectedParameter_isPresent () const;

    class userdataAB
    {
    public:
        typedef ASN1::OpenData value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class userdataAB

    userdataAB::const_reference get_userdataAB () const;
    userdataAB::reference ref_userdataAB ();
    userdataAB::reference set_userdataAB ();
    userdataAB::reference set_userdataAB (userdataAB::const_reference v);
    void omit_userdataAB ();
    bool userdataAB_isPresent () const;
    void swap(RTABapdu& that);
    RTABapdu * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static unsigned fieldTags[3];
    static const char* fieldNames[3];
}; // end class RTABapdu

//
// SessionConnectionIdentifier
//

class ACSE_1_API SessionConnectionIdentifier : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    SessionConnectionIdentifier(const void* info) : Inherited(info) {}
public:
    SessionConnectionIdentifier() : Inherited(&theInfo) {}
    SessionConnectionIdentifier(const SessionConnectionIdentifier & that) : Inherited(that) {}

    SessionConnectionIdentifier& operator=(const SessionConnectionIdentifier& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_additionalReferenceInformation
    };

    class callingSSuserReference
    {
    public:
        typedef CallingSSuserReference value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class callingSSuserReference

    callingSSuserReference::const_reference get_callingSSuserReference () const;
    callingSSuserReference::reference ref_callingSSuserReference ();
    callingSSuserReference::reference set_callingSSuserReference ();
    callingSSuserReference::reference set_callingSSuserReference (callingSSuserReference::const_reference v);

    class commonReference
    {
    public:
        typedef CommonReference value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class commonReference

    commonReference::const_reference get_commonReference () const;
    commonReference::reference ref_commonReference ();
    commonReference::reference set_commonReference ();
    commonReference::reference set_commonReference (commonReference::const_reference v);

    class additionalReferenceInformation
    {
    public:
        typedef AdditionalReferenceInformation value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class additionalReferenceInformation

    additionalReferenceInformation::const_reference get_additionalReferenceInformation () const;
    additionalReferenceInformation::reference ref_additionalReferenceInformation ();
    additionalReferenceInformation::reference set_additionalReferenceInformation ();
    additionalReferenceInformation::reference set_additionalReferenceInformation (const ASN1_STD string& v);
    void omit_additionalReferenceInformation ();
    bool additionalReferenceInformation_isPresent () const;
    void swap(SessionConnectionIdentifier& that);
    SessionConnectionIdentifier * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static unsigned fieldTags[3];
    static const char* fieldNames[3];
}; // end class SessionConnectionIdentifier

//
// ConnectionData
//

class ACSE_1_API ConnectionData : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    ConnectionData(const void* info) : Inherited(info) {}
public:
    ConnectionData() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      open0 = 0,
      recover1 = 1
    };

    class open
    {
    public:
        enum Id { eid = 0 };
        typedef ASN1::OpenData value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class open

    open::const_reference get_open () const;
    open::reference ref_open ();
    open::reference select_open ();
    open::reference select_open (open::const_reference v);
    bool open_isSelected() const;

    ConnectionData(open::Id id, ConnectionData::open::const_reference v);

    class recover
    {
    public:
        enum Id { eid = 1 };
        typedef SessionConnectionIdentifier value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class recover

    recover::const_reference get_recover () const;
    recover::reference ref_recover ();
    recover::reference select_recover ();
    recover::reference select_recover (recover::const_reference v);
    bool recover_isSelected() const;

    ConnectionData(recover::Id id, ConnectionData::recover::const_reference v);
    ConnectionData(const ConnectionData & that)     : Inherited(that) {}

    ConnectionData & operator=(const ConnectionData & that)
    { Inherited::operator=(that); return *this; }

    void swap(ConnectionData & that) { Inherited::swap(that); }

    ConnectionData * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[2];
    static unsigned selectionTags[2];
    static const char* selectionNames[2];
}; // end class ConnectionData

//
// RTORQapdu
//

class ACSE_1_API RTORQapdu : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RTORQapdu(const void* info) : Inherited(info) {}
public:
    RTORQapdu() : Inherited(&theInfo) {}
    RTORQapdu(const RTORQapdu & that) : Inherited(that) {}

    RTORQapdu& operator=(const RTORQapdu& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_checkpointSize,
      e_windowSize,
      e_dialogueMode,
      e_applicationProtocol
    };

    class checkpointSize
    {
    public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class checkpointSize

    checkpointSize::const_reference get_checkpointSize () const;
    checkpointSize::reference ref_checkpointSize ();
    checkpointSize::reference set_checkpointSize ();
    checkpointSize::reference set_checkpointSize (checkpointSize::value_type::int_type v);
    void omit_checkpointSize ();
    bool checkpointSize_isPresent () const;

    class windowSize
    {
    public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class windowSize

    windowSize::const_reference get_windowSize () const;
    windowSize::reference ref_windowSize ();
    windowSize::reference set_windowSize ();
    windowSize::reference set_windowSize (windowSize::value_type::int_type v);
    void omit_windowSize ();
    bool windowSize_isPresent () const;

    class dialogueMode
    {
    public:
        class ACSE_1_API value_type : public ASN1::IntegerWithNamedNumber
        {
            typedef ASN1::IntegerWithNamedNumber Inherited;
        protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
        public:
            value_type(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
            enum NamedNumber {
                monologue,
                twa
            };

            bool is_monologue() const { return value == monologue; }
            void set_monologue() { value = monologue; }

            bool is_twa() const { return value == twa; }
            void set_twa() { value = twa; }

            value_type(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
            value_type & operator=(int_type v) { setValue(v); return *this; }
            operator NamedNumber() const { return NamedNumber(getValue()); }

            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData& type);
            static const InfoType theInfo;
        private:
            static const NameEntry nameEntries[2];
        }; // end class value_type

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class dialogueMode

    dialogueMode::const_reference get_dialogueMode () const;
    dialogueMode::reference ref_dialogueMode ();
    dialogueMode::reference set_dialogueMode ();
    dialogueMode::reference set_dialogueMode (dialogueMode::value_type::int_type v);
    void omit_dialogueMode ();
    bool dialogueMode_isPresent () const;

    class connectionDataRQ
    {
    public:
        typedef ConnectionData value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class connectionDataRQ

    connectionDataRQ::const_reference get_connectionDataRQ () const;
    connectionDataRQ::reference ref_connectionDataRQ ();
    connectionDataRQ::reference set_connectionDataRQ ();
    connectionDataRQ::reference set_connectionDataRQ (connectionDataRQ::const_reference v);

    class applicationProtocol
    {
    public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class applicationProtocol

    applicationProtocol::const_reference get_applicationProtocol () const;
    applicationProtocol::reference ref_applicationProtocol ();
    applicationProtocol::reference set_applicationProtocol ();
    applicationProtocol::reference set_applicationProtocol (applicationProtocol::value_type::int_type v);
    void omit_applicationProtocol ();
    bool applicationProtocol_isPresent () const;
    void swap(RTORQapdu& that);
    RTORQapdu * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static unsigned fieldTags[5];
    static const char* fieldNames[5];
}; // end class RTORQapdu

//
// RTOACapdu
//

class ACSE_1_API RTOACapdu : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RTOACapdu(const void* info) : Inherited(info) {}
public:
    RTOACapdu() : Inherited(&theInfo) {}
    RTOACapdu(const RTOACapdu & that) : Inherited(that) {}

    RTOACapdu& operator=(const RTOACapdu& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_checkpointSize,
      e_windowSize
    };

    class checkpointSize
    {
    public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class checkpointSize

    checkpointSize::const_reference get_checkpointSize () const;
    checkpointSize::reference ref_checkpointSize ();
    checkpointSize::reference set_checkpointSize ();
    checkpointSize::reference set_checkpointSize (checkpointSize::value_type::int_type v);
    void omit_checkpointSize ();
    bool checkpointSize_isPresent () const;

    class windowSize
    {
    public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class windowSize

    windowSize::const_reference get_windowSize () const;
    windowSize::reference ref_windowSize ();
    windowSize::reference set_windowSize ();
    windowSize::reference set_windowSize (windowSize::value_type::int_type v);
    void omit_windowSize ();
    bool windowSize_isPresent () const;

    class connectionDataAC
    {
    public:
        typedef ConnectionData value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class connectionDataAC

    connectionDataAC::const_reference get_connectionDataAC () const;
    connectionDataAC::reference ref_connectionDataAC ();
    connectionDataAC::reference set_connectionDataAC ();
    connectionDataAC::reference set_connectionDataAC (connectionDataAC::const_reference v);
    void swap(RTOACapdu& that);
    RTOACapdu * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static unsigned fieldTags[3];
    static const char* fieldNames[3];
}; // end class RTOACapdu

//
// RTSE_apdus
//

class ACSE_1_API RTSE_apdus : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RTSE_apdus(const void* info) : Inherited(info) {}
public:
    RTSE_apdus() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      rtorq_apdu0 = 0,
      rtoac_apdu1 = 1,
      rtorj_apdu2 = 2,
      rttp_apdu3 = 3,
      rttr_apdu4 = 4,
      rtab_apdu5 = 5
    };

    class rtorq_apdu
    {
    public:
        enum Id { eid = 0 };
        typedef RTORQapdu value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class rtorq_apdu

    rtorq_apdu::const_reference get_rtorq_apdu () const;
    rtorq_apdu::reference ref_rtorq_apdu ();
    rtorq_apdu::reference select_rtorq_apdu ();
    rtorq_apdu::reference select_rtorq_apdu (rtorq_apdu::const_reference v);
    bool rtorq_apdu_isSelected() const;

    RTSE_apdus(rtorq_apdu::Id id, RTSE_apdus::rtorq_apdu::const_reference v);

    class rtoac_apdu
    {
    public:
        enum Id { eid = 1 };
        typedef RTOACapdu value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class rtoac_apdu

    rtoac_apdu::const_reference get_rtoac_apdu () const;
    rtoac_apdu::reference ref_rtoac_apdu ();
    rtoac_apdu::reference select_rtoac_apdu ();
    rtoac_apdu::reference select_rtoac_apdu (rtoac_apdu::const_reference v);
    bool rtoac_apdu_isSelected() const;

    RTSE_apdus(rtoac_apdu::Id id, RTSE_apdus::rtoac_apdu::const_reference v);

    class rtorj_apdu
    {
    public:
        enum Id { eid = 2 };
        typedef RTORJapdu value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class rtorj_apdu

    rtorj_apdu::const_reference get_rtorj_apdu () const;
    rtorj_apdu::reference ref_rtorj_apdu ();
    rtorj_apdu::reference select_rtorj_apdu ();
    rtorj_apdu::reference select_rtorj_apdu (rtorj_apdu::const_reference v);
    bool rtorj_apdu_isSelected() const;

    RTSE_apdus(rtorj_apdu::Id id, RTSE_apdus::rtorj_apdu::const_reference v);

    class rttp_apdu
    {
    public:
        enum Id { eid = 3 };
        typedef RTTPapdu value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class rttp_apdu

    rttp_apdu::const_reference get_rttp_apdu () const;
    rttp_apdu::reference ref_rttp_apdu ();
    rttp_apdu::reference select_rttp_apdu ();
    rttp_apdu::reference select_rttp_apdu (rttp_apdu::value_type::int_type v);
    bool rttp_apdu_isSelected() const;

    RTSE_apdus(rttp_apdu::Id id, RTSE_apdus::rttp_apdu::value_type::int_type v);

    class rttr_apdu
    {
    public:
        enum Id { eid = 4 };
        typedef RTTRapdu value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class rttr_apdu

    rttr_apdu::const_reference get_rttr_apdu () const;
    rttr_apdu::reference ref_rttr_apdu ();
    rttr_apdu::reference select_rttr_apdu ();
    rttr_apdu::reference select_rttr_apdu (const ASN1_STD vector<char>& v);
    bool rttr_apdu_isSelected() const;

    RTSE_apdus(rttr_apdu::Id id, const ASN1_STD vector<char>& v);

    class rtab_apdu
    {
    public:
        enum Id { eid = 5 };
        typedef RTABapdu value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class rtab_apdu

    rtab_apdu::const_reference get_rtab_apdu () const;
    rtab_apdu::reference ref_rtab_apdu ();
    rtab_apdu::reference select_rtab_apdu ();
    rtab_apdu::reference select_rtab_apdu (rtab_apdu::const_reference v);
    bool rtab_apdu_isSelected() const;

    RTSE_apdus(rtab_apdu::Id id, RTSE_apdus::rtab_apdu::const_reference v);
    RTSE_apdus(const RTSE_apdus & that)     : Inherited(that) {}

    RTSE_apdus & operator=(const RTSE_apdus & that)
    { Inherited::operator=(that); return *this; }

    void swap(RTSE_apdus & 