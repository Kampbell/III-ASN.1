//
// iso8823_presentation.h
//
// Code automatically generated by asnparser.
//

#ifndef __ISO8823_PRESENTATION_H
#define __ISO8823_PRESENTATION_H

#include "asn1.h"

#include "reliable_transfer_apdu.h"



#ifndef ACSE_1_DEFINED
#define ACSE_1_DEFINED

#include "Platform.h"

#if defined(_WIN32)
	#include "Platform_WIN32.h"
#elif defined(__VMS)
	#include "Platform_VMS.h"
#elif defined(ALS_VXWORKS)
	#include "Platform_VX.h"
#elif defined(ALS_OS_FAMILY_UNIX)
	#include "Platform_POSIX.h"
#endif

//
// Ensure that ACSE_1_DLL is default unless ACSE_1_STATIC is defined
//
#if defined(_WIN32) && defined(_DLL)
	#if !defined(ACSE_1_DLL) && !defined(ACSE_1_STATIC)
		#define ACSE_1_DLL
	#endif
#endif

#if defined(_MSC_VER)
	#if defined(ACSE_1_DLL)
		#if defined(_DEBUG)
			#define ACSE_1_LIB_SUFFIX "d.lib"
		#else
			#define ACSE_1_LIB_SUFFIX ".lib"
		#endif
	#elif defined(_DLL)
		#if defined(_DEBUG)
			#define ACSE_1_LIB_SUFFIX "mdd.lib"
		#else
			#define ACSE_1_LIB_SUFFIX "md.lib"
		#endif
	#else
		#if defined(_DEBUG)
			#define ACSE_1_LIB_SUFFIX "mtd.lib"
		#else
			#define ACSE_1_LIB_SUFFIX "mt.lib"
		#endif
	#endif
#endif

//
// The following block is the standard way of creating macros which make exporting
// from a DLL simpler. All files within this DLL are compiled with the ACSE_1_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see
// ACSE_1_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
//
#if defined(_WIN32) && defined(ACSE_1_DLL)
	#if defined(ACSE_1_EXPORTS)
		#define ACSE_1_API __declspec(dllexport)
	#else
		#define ACSE_1_API __declspec(dllimport)
	#endif
#endif

#if !defined(ACSE_1_API)
	#define ACSE_1_API
#endif

//
// Automatically link ACSE_1 library.
//
#if defined(_MSC_VER)
	#if !defined(ACSE_1_NO_AUTOMATIC_LIBS) && !defined(ACSE_1_EXPORTS)
		#pragma comment(lib, "ACSE_1" ACSE_1_LIB_SUFFIX)
	#endif
#endif
#endif

namespace ISO8823_PRESENTATION {

using ASN1::ABSTRACT_SYNTAX;
//
// Abort_reason
//

class ACSE_1_API Abort_reason : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Abort_reason(const void* info) : Inherited(info) {}
public:
    Abort_reason(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        reason_not_specified,
        unrecognized_ppdu,
        unexpected_ppdu,
        unexpected_session_service_primitive,
        unrecognized_ppdu_parameter,
        unexpected_ppdu_parameter,
        invalid_ppdu_parameter_value
    };

    bool is_reason_not_specified() const { return value == reason_not_specified; }
    void set_reason_not_specified() { value = reason_not_specified; }

    bool is_unrecognized_ppdu() const { return value == unrecognized_ppdu; }
    void set_unrecognized_ppdu() { value = unrecognized_ppdu; }

    bool is_unexpected_ppdu() const { return value == unexpected_ppdu; }
    void set_unexpected_ppdu() { value = unexpected_ppdu; }

    bool is_unexpected_session_service_primitive() const { return value == unexpected_session_service_primitive; }
    void set_unexpected_session_service_primitive() { value = unexpected_session_service_primitive; }

    bool is_unrecognized_ppdu_parameter() const { return value == unrecognized_ppdu_parameter; }
    void set_unrecognized_ppdu_parameter() { value = unrecognized_ppdu_parameter; }

    bool is_unexpected_ppdu_parameter() const { return value == unexpected_ppdu_parameter; }
    void set_unexpected_ppdu_parameter() { value = unexpected_ppdu_parameter; }

    bool is_invalid_ppdu_parameter_value() const { return value == invalid_ppdu_parameter_value; }
    void set_invalid_ppdu_parameter_value() { value = invalid_ppdu_parameter_value; }

    Abort_reason(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    Abort_reason & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    Abort_reason * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[7];
}; // end class Abort_reason

typedef ASN1::OBJECT_IDENTIFIER Abstract_syntax_name;

//
// Event_identifier
//

class ACSE_1_API Event_identifier : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Event_identifier(const void* info) : Inherited(info) {}
public:
    Event_identifier(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        cp_PPDU,
        cpa_PPDU,
        cpr_PPDU,
        aru_PPDU,
        arp_PPDU,
        ac_PPDU,
        aca_PPDU,
        td_PPDU,
        ttd_PPDU,
        te_PPDU,
        tc_PPDU,
        tcc_PPDU,
        rs_PPDU,
        rsa_PPDU,
        s_release_indication,
        s_release_confirm,
        s_token_give_indication,
        s_token_please_indication,
        s_control_give_indication,
        s_sync_minor_indication,
        s_sync_minor_confirm,
        s_sync_major_indication,
        s_sync_major_confirm,
        s_p_exception_report_indication,
        s_u_exception_report_indication,
        s_activity_start_indication,
        s_activity_resume_indication,
        s_activity_interrupt_indication,
        s_activity_interrupt_confirm,
        s_activity_discard_indication,
        s_activity_discard_confirm,
        s_activity_end_indication,
        s_activity_end_confirm
    };

    bool is_cp_PPDU() const { return value == cp_PPDU; }
    void set_cp_PPDU() { value = cp_PPDU; }

    bool is_cpa_PPDU() const { return value == cpa_PPDU; }
    void set_cpa_PPDU() { value = cpa_PPDU; }

    bool is_cpr_PPDU() const { return value == cpr_PPDU; }
    void set_cpr_PPDU() { value = cpr_PPDU; }

    bool is_aru_PPDU() const { return value == aru_PPDU; }
    void set_aru_PPDU() { value = aru_PPDU; }

    bool is_arp_PPDU() const { return value == arp_PPDU; }
    void set_arp_PPDU() { value = arp_PPDU; }

    bool is_ac_PPDU() const { return value == ac_PPDU; }
    void set_ac_PPDU() { value = ac_PPDU; }

    bool is_aca_PPDU() const { return value == aca_PPDU; }
    void set_aca_PPDU() { value = aca_PPDU; }

    bool is_td_PPDU() const { return value == td_PPDU; }
    void set_td_PPDU() { value = td_PPDU; }

    bool is_ttd_PPDU() const { return value == ttd_PPDU; }
    void set_ttd_PPDU() { value = ttd_PPDU; }

    bool is_te_PPDU() const { return value == te_PPDU; }
    void set_te_PPDU() { value = te_PPDU; }

    bool is_tc_PPDU() const { return value == tc_PPDU; }
    void set_tc_PPDU() { value = tc_PPDU; }

    bool is_tcc_PPDU() const { return value == tcc_PPDU; }
    void set_tcc_PPDU() { value = tcc_PPDU; }

    bool is_rs_PPDU() const { return value == rs_PPDU; }
    void set_rs_PPDU() { value = rs_PPDU; }

    bool is_rsa_PPDU() const { return value == rsa_PPDU; }
    void set_rsa_PPDU() { value = rsa_PPDU; }

    bool is_s_release_indication() const { return value == s_release_indication; }
    void set_s_release_indication() { value = s_release_indication; }

    bool is_s_release_confirm() const { return value == s_release_confirm; }
    void set_s_release_confirm() { value = s_release_confirm; }

    bool is_s_token_give_indication() const { return value == s_token_give_indication; }
    void set_s_token_give_indication() { value = s_token_give_indication; }

    bool is_s_token_please_indication() const { return value == s_token_please_indication; }
    void set_s_token_please_indication() { value = s_token_please_indication; }

    bool is_s_control_give_indication() const { return value == s_control_give_indication; }
    void set_s_control_give_indication() { value = s_control_give_indication; }

    bool is_s_sync_minor_indication() const { return value == s_sync_minor_indication; }
    void set_s_sync_minor_indication() { value = s_sync_minor_indication; }

    bool is_s_sync_minor_confirm() const { return value == s_sync_minor_confirm; }
    void set_s_sync_minor_confirm() { value = s_sync_minor_confirm; }

    bool is_s_sync_major_indication() const { return value == s_sync_major_indication; }
    void set_s_sync_major_indication() { value = s_sync_major_indication; }

    bool is_s_sync_major_confirm() const { return value == s_sync_major_confirm; }
    void set_s_sync_major_confirm() { value = s_sync_major_confirm; }

    bool is_s_p_exception_report_indication() const { return value == s_p_exception_report_indication; }
    void set_s_p_exception_report_indication() { value = s_p_exception_report_indication; }

    bool is_s_u_exception_report_indication() const { return value == s_u_exception_report_indication; }
    void set_s_u_exception_report_indication() { value = s_u_exception_report_indication; }

    bool is_s_activity_start_indication() const { return value == s_activity_start_indication; }
    void set_s_activity_start_indication() { value = s_activity_start_indication; }

    bool is_s_activity_resume_indication() const { return value == s_activity_resume_indication; }
    void set_s_activity_resume_indication() { value = s_activity_resume_indication; }

    bool is_s_activity_interrupt_indication() const { return value == s_activity_interrupt_indication; }
    void set_s_activity_interrupt_indication() { value = s_activity_interrupt_indication; }

    bool is_s_activity_interrupt_confirm() const { return value == s_activity_interrupt_confirm; }
    void set_s_activity_interrupt_confirm() { value = s_activity_interrupt_confirm; }

    bool is_s_activity_discard_indication() const { return value == s_activity_discard_indication; }
    void set_s_activity_discard_indication() { value = s_activity_discard_indication; }

    bool is_s_activity_discard_confirm() const { return value == s_activity_discard_confirm; }
    void set_s_activity_discard_confirm() { value = s_activity_discard_confirm; }

    bool is_s_activity_end_indication() const { return value == s_activity_end_indication; }
    void set_s_activity_end_indication() { value = s_activity_end_indication; }

    bool is_s_activity_end_confirm() const { return value == s_activity_end_confirm; }
    void set_s_activity_end_confirm() { value = s_activity_end_confirm; }

    Event_identifier(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    Event_identifier & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    Event_identifier * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[33];
}; // end class Event_identifier

//
// Mode_selector
//

class ACSE_1_API Mode_selector : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Mode_selector(const void* info) : Inherited(info) {}
public:
    Mode_selector() : Inherited(&theInfo) {}
    Mode_selector(const Mode_selector & that) : Inherited(that) {}

    Mode_selector& operator=(const Mode_selector& that)
    { Inherited::operator=(that); return *this; }


    class mode_value
    {
    public:
        class ACSE_1_API value_type : public ASN1::IntegerWithNamedNumber
        {
            typedef ASN1::IntegerWithNamedNumber Inherited;
        protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
        public:
            value_type(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
            enum NamedNumber {
                x410_1984_mode,
                normal_mode
            };

            bool is_x410_1984_mode() const { return value == x410_1984_mode; }
            void set_x410_1984_mode() { value = x410_1984_mode; }

            bool is_normal_mode() const { return value == normal_mode; }
            void set_normal_mode() { value = normal_mode; }

            value_type(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
            value_type & operator=(int_type v) { setValue(v); return *this; }
            operator NamedNumber() const { return NamedNumber(getValue()); }

            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData& type);
            static const InfoType theInfo;
        private:
            static const NameEntry nameEntries[2];
        }; // end class value_type

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class mode_value

    mode_value::const_reference get_mode_value () const;
    mode_value::reference ref_mode_value ();
    mode_value::reference set_mode_value ();
    mode_value::reference set_mode_value (mode_value::value_type::int_type v);
    void swap(Mode_selector& that);
    Mode_selector * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
}; // end class Mode_selector

typedef ASN1::Constrained_INTEGER<ASN1::ExtendableConstraint, 1, 127 >  Presentation_context_identifier;

//
// Presentation_requirements
//

class ACSE_1_API Presentation_requirements : public ASN1::BIT_STRING
{
    typedef ASN1::BIT_STRING Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Presentation_requirements(const void* info) : Inherited(info) {}
public:
    Presentation_requirements() : Inherited(&theInfo) {}

    enum NamedBits {
        context_management,
        restoration
    };

    Presentation_requirements * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const char * nameList[];
}; // end class Presentation_requirements

typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::ExtendableConstraint, 1, 4 > >  Presentation_selector;

//
// Protocol_options
//

class ACSE_1_API Protocol_options : public ASN1::BIT_STRING
{
    typedef ASN1::BIT_STRING Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Protocol_options(const void* info) : Inherited(info) {}
public:
    Protocol_options() : Inherited(&theInfo) {}

    enum NamedBits {
        nominated_context,
        short_encoding,
        packed_encoding_rules
    };

    Protocol_options * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const char * nameList[];
}; // end class Protocol_options

//
// Protocol_version
//

class ACSE_1_API Protocol_version : public ASN1::BIT_STRING
{
    typedef ASN1::BIT_STRING Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Protocol_version(const void* info) : Inherited(info) {}
public:
    Protocol_version() : Inherited(&theInfo) {}

    enum NamedBits {
        version_1
    };

    Protocol_version * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const char * nameList[];
}; // end class Protocol_version

//
// Provider_reason
//

class ACSE_1_API Provider_reason : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Provider_reason(const void* info) : Inherited(info) {}
public:
    Provider_reason(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        reason_not_specified,
        temporary_congestion,
        local_limit_exceeded,
        called_presentation_address_unknown,
        protocol_version_not_supported,
        default_context_not_supported,
        user_data_not_readable,
        no_PSAP_available
    };

    bool is_reason_not_specified() const { return value == reason_not_specified; }
    void set_reason_not_specified() { value = reason_not_specified; }

    bool is_temporary_congestion() const { return value == temporary_congestion; }
    void set_temporary_congestion() { value = temporary_congestion; }

    bool is_local_limit_exceeded() const { return value == local_limit_exceeded; }
    void set_local_limit_exceeded() { value = local_limit_exceeded; }

    bool is_called_presentation_address_unknown() const { return value == called_presentation_address_unknown; }
    void set_called_presentation_address_unknown() { value = called_presentation_address_unknown; }

    bool is_protocol_version_not_supported() const { return value == protocol_version_not_supported; }
    void set_protocol_version_not_supported() { value = protocol_version_not_supported; }

    bool is_default_context_not_supported() const { return value == default_context_not_supported; }
    void set_default_context_not_supported() { value = default_context_not_supported; }

    bool is_user_data_not_readable() const { return value == user_data_not_readable; }
    void set_user_data_not_readable() { value = user_data_not_readable; }

    bool is_no_PSAP_available() const { return value == no_PSAP_available; }
    void set_no_PSAP_available() { value = no_PSAP_available; }

    Provider_reason(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    Provider_reason & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    Provider_reason * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[8];
}; // end class Provider_reason

typedef Presentation_selector Responding_presentation_selector;
//
// Result
//

class ACSE_1_API Result : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Result(const void* info) : Inherited(info) {}
public:
    Result(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        acceptance,
        user_rejection,
        provider_rejection
    };

    bool is_acceptance() const { return value == acceptance; }
    void set_acceptance() { value = acceptance; }

    bool is_user_rejection() const { return value == user_rejection; }
    void set_user_rejection() { value = user_rejection; }

    bool is_provider_rejection() const { return value == provider_rejection; }
    void set_provider_rejection() { value = provider_rejection; }

    Result(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    Result & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    Result * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[3];
}; // end class Result

typedef ASN1::OBJECT_IDENTIFIER Transfer_syntax_name;

typedef ASN1::OCTET_STRING Simply_encoded_data;

//
// User_session_requirements
//

class ACSE_1_API User_session_requirements : public ASN1::BIT_STRING
{
    typedef ASN1::BIT_STRING Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    User_session_requirements(const void* info) : Inherited(info) {}
public:
    User_session_requirements() : Inherited(&theInfo) {}

    enum NamedBits {
        half_duplex,
        duplex,
        expedited_data,
        minor_synchronize,
        major_synchronize,
        resynchronize,
        activity_management,
        negotiated_release,
        capability_data,
        exceptions,
        typed_data,
        symmetric_synchronize,
        data_separation
    };

    User_session_requirements * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const char * nameList[];
}; // end class User_session_requirements

//
// CP_type_x410_mode_parameters
//

class ACSE_1_API CP_type_x410_mode_parameters : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CP_type_x410_mode_parameters(const void* info) : Inherited(info) {}
public:
    CP_type_x410_mode_parameters() : Inherited(&theInfo) {}
    CP_type_x410_mode_parameters(const CP_type_x410_mode_parameters & that) : Inherited(that) {}

    CP_type_x410_mode_parameters& operator=(const CP_type_x410_mode_parameters& that)
    { Inherited::operator=(that); return *this; }


    class 
    {
    public:
        typedef Reliable_Transfer_APDURTORQapdu value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class 

    ::const_reference get_ () const;
    ::reference ref_ ();
    ::reference set_ ();
    ::reference set_ ( v);
    void swap(CP_type_x410_mode_parameters& that);
    CP_type_x410_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
}; // end class CP_type_x410_mode_parameters

//
// CPA_PPDU_x410_mode_parameters
//

class ACSE_1_API CPA_PPDU_x410_mode_parameters : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CPA_PPDU_x410_mode_parameters(const void* info) : Inherited(info) {}
public:
    CPA_PPDU_x410_mode_parameters() : Inherited(&theInfo) {}
    CPA_PPDU_x410_mode_parameters(const CPA_PPDU_x410_mode_parameters & that) : Inherited(that) {}

    CPA_PPDU_x410_mode_parameters& operator=(const CPA_PPDU_x410_mode_parameters& that)
    { Inherited::operator=(that); return *this; }


    class 
    {
    public:
        typedef Reliable_Transfer_APDURTOACapdu value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class 

    ::const_reference get_ () const;
    ::reference ref_ ();
    ::reference set_ ();
    ::reference set_ ( v);
    void swap(CPA_PPDU_x410_mode_parameters& that);
    CPA_PPDU_x410_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
}; // end class CPA_PPDU_x410_mode_parameters

//
// CPR_PPDU_x400_mode_parameters
//

class ACSE_1_API CPR_PPDU_x400_mode_parameters : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CPR_PPDU_x400_mode_parameters(const void* info) : Inherited(info) {}
public:
    CPR_PPDU_x400_mode_parameters() : Inherited(&theInfo) {}
    CPR_PPDU_x400_mode_parameters(const CPR_PPDU_x400_mode_parameters & that) : Inherited(that) {}

    CPR_PPDU_x400_mode_parameters& operator=(const CPR_PPDU_x400_mode_parameters& that)
    { Inherited::operator=(that); return *this; }


    class 
    {
    public:
        typedef Reliable_Transfer_APDURTORJapdu value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class 

    ::const_reference get_ () const;
    ::reference ref_ ();
    ::reference set_ ();
    ::reference set_ ( v);
    void swap(CPR_PPDU_x400_mode_parameters& that);
    CPR_PPDU_x400_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
}; // end class CPR_PPDU_x400_mode_parameters

//
// ARU_PPDU_x400_mode_parameters
//

class ACSE_1_API ARU_PPDU_x400_mode_parameters : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    ARU_PPDU_x400_mode_parameters(const void* info) : Inherited(info) {}
public:
    ARU_PPDU_x400_mode_parameters() : Inherited(&theInfo) {}
    ARU_PPDU_x400_mode_parameters(const ARU_PPDU_x400_mode_parameters & that) : Inherited(that) {}

    ARU_PPDU_x400_mode_parameters& operator=(const ARU_PPDU_x400_mode_parameters& that)
    { Inherited::operator=(that); return *this; }


    class 
    {
    public:
        typedef Reliable_Transfer_APDURTABapdu value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class 

    ::const_reference get_ () const;
    ::reference ref_ ();
    ::reference set_ ();
    ::reference set_ ( v);
    void swap(ARU_PPDU_x400_mode_parameters& that);
    ARU_PPDU_x400_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
}; // end class ARU_PPDU_x400_mode_parameters

//
// Context_list_subtype
//

class ACSE_1_API Context_list_subtype : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Context_list_subtype(const void* info) : Inherited(info) {}
public:
    Context_list_subtype() : Inherited(&theInfo) {}
    Context_list_subtype(const Context_list_subtype & that) : Inherited(that) {}

    Context_list_subtype& operator=(const Context_list_subtype& that)
    { Inherited::operator=(that); return *this; }


    class presentation_context_identifier
    {
    public:
        typedef Presentation_context_identifier value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_identifier

    presentation_context_identifier::const_reference get_presentation_context_identifier () const;
    presentation_context_identifier::reference ref_presentation_context_identifier ();
    presentation_context_identifier::reference set_presentation_context_identifier ();
    presentation_context_identifier::reference set_presentation_context_identifier (presentation_context_identifier::value_type::int_type v);

    class abstract_syntax_name
    {
    public:
        typedef Abstract_syntax_name value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class abstract_syntax_name

    abstract_syntax_name::const_reference get_abstract_syntax_name () const;
    abstract_syntax_name::reference ref_abstract_syntax_name ();
    abstract_syntax_name::reference set_abstract_syntax_name ();
    abstract_syntax_name::reference set_abstract_syntax_name (abstract_syntax_name::const_reference v);

    class transfer_syntax_name_list
    {
    public:
        typedef ASN1::SEQUENCE_OF<Transfer_syntax_name>  value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class transfer_syntax_name_list

    transfer_syntax_name_list::const_reference get_transfer_syntax_name_list () const;
    transfer_syntax_name_list::reference ref_transfer_syntax_name_list ();
    transfer_syntax_name_list::reference set_transfer_syntax_name_list ();
    transfer_syntax_name_list::reference set_transfer_syntax_name_list (transfer_syntax_name_list::const_reference v);
    void swap(Context_list_subtype& that);
    Context_list_subtype * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
}; // end class Context_list_subtype

//
// Presentation_context_deletion_result_list_subtype
//

class ACSE_1_API Presentation_context_deletion_result_list_subtype : public ASN1::IntegerWithNamedNumber
{
    typedef ASN1::IntegerWithNamedNumber Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Presentation_context_deletion_result_list_subtype(const void* info) : Inherited(info) {}
public:
    Presentation_context_deletion_result_list_subtype(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
    enum NamedNumber {
        acceptance,
        user_rejection
    };

    bool is_acceptance() const { return value == acceptance; }
    void set_acceptance() { value = acceptance; }

    bool is_user_rejection() const { return value == user_rejection; }
    void set_user_rejection() { value = user_rejection; }

    Presentation_context_deletion_result_list_subtype(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
    Presentation_context_deletion_result_list_subtype & operator=(int_type v) { setValue(v); return *this; }
    operator NamedNumber() const { return NamedNumber(getValue()); }

    Presentation_context_deletion_result_list_subtype * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const NameEntry nameEntries[2];
}; // end class Presentation_context_deletion_result_list_subtype

//
// Presentation_context_identifier_list_subtype
//

class ACSE_1_API Presentation_context_identifier_list_subtype : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Presentation_context_identifier_list_subtype(const void* info) : Inherited(info) {}
public:
    Presentation_context_identifier_list_subtype() : Inherited(&theInfo) {}
    Presentation_context_identifier_list_subtype(const Presentation_context_identifier_list_subtype & that) : Inherited(that) {}

    Presentation_context_identifier_list_subtype& operator=(const Presentation_context_identifier_list_subtype& that)
    { Inherited::operator=(that); return *this; }


    class presentation_context_identifier
    {
    public:
        typedef Presentation_context_identifier value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_identifier

    presentation_context_identifier::const_reference get_presentation_context_identifier () const;
    presentation_context_identifier::reference ref_presentation_context_identifier ();
    presentation_context_identifier::reference set_presentation_context_identifier ();
    presentation_context_identifier::reference set_presentation_context_identifier (presentation_context_identifier::value_type::int_type v);

    class transfer_syntax_name
    {
    public:
        typedef Transfer_syntax_name value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class transfer_syntax_name

    transfer_syntax_name::const_reference get_transfer_syntax_name () const;
    transfer_syntax_name::reference ref_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name (transfer_syntax_name::const_reference v);
    void swap(Presentation_context_identifier_list_subtype& that);
    Presentation_context_identifier_list_subtype * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
}; // end class Presentation_context_identifier_list_subtype

//
// Result_list_subtype
//

class ACSE_1_API Result_list_subtype : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Result_list_subtype(const void* info) : Inherited(info) {}
public:
    Result_list_subtype() : Inherited(&theInfo) {}
    Result_list_subtype(const Result_list_subtype & that) : Inherited(that) {}

    Result_list_subtype& operator=(const Result_list_subtype& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_transfer_syntax_name,
      e_provider_reason
    };

    class result
    {
    public:
        typedef Result value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class result

    result::const_reference get_result () const;
    result::reference ref_result ();
    result::reference set_result ();
    result::reference set_result (result::value_type::int_type v);

    class transfer_syntax_name
    {
    public:
        typedef Transfer_syntax_name value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class transfer_syntax_name

    transfer_syntax_name::const_reference get_transfer_syntax_name () const;
    transfer_syntax_name::reference ref_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name (transfer_syntax_name::const_reference v);
    void omit_transfer_syntax_name ();
    bool transfer_syntax_name_isPresent () const;

    class provider_reason
    {
    public:
        class ACSE_1_API value_type : public ASN1::IntegerWithNamedNumber
        {
            typedef ASN1::IntegerWithNamedNumber Inherited;
        protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
        public:
            value_type(int_type v =0, const void* info =&theInfo) : Inherited(v, info) {}
            enum NamedNumber {
                reason_not_specified,
                abstract_syntax_not_supported,
                proposed_transfer_syntaxes_not_supported,
                local_limit_on_DCS_exceeded
            };

            bool is_reason_not_specified() const { return value == reason_not_specified; }
            void set_reason_not_specified() { value = reason_not_specified; }

            bool is_abstract_syntax_not_supported() const { return value == abstract_syntax_not_supported; }
            void set_abstract_syntax_not_supported() { value = abstract_syntax_not_supported; }

            bool is_proposed_transfer_syntaxes_not_supported() const { return value == proposed_transfer_syntaxes_not_supported; }
            void set_proposed_transfer_syntaxes_not_supported() { value = proposed_transfer_syntaxes_not_supported; }

            bool is_local_limit_on_DCS_exceeded() const { return value == local_limit_on_DCS_exceeded; }
            void set_local_limit_on_DCS_exceeded() { value = local_limit_on_DCS_exceeded; }

            value_type(NamedNumber v, const void* info =&theInfo) : Inherited(v, info) {}
            value_type & operator=(int_type v) { setValue(v); return *this; }
            operator NamedNumber() const { return NamedNumber(getValue()); }

            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData& type);
            static const InfoType theInfo;
        private:
            static const NameEntry nameEntries[4];
        }; // end class value_type

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class provider_reason

    provider_reason::const_reference get_provider_reason () const;
    provider_reason::reference ref_provider_reason ();
    provider_reason::reference set_provider_reason ();
    provider_reason::reference set_provider_reason (provider_reason::value_type::int_type v);
    void omit_provider_reason ();
    bool provider_reason_isPresent () const;
    void swap(Result_list_subtype& that);
    Result_list_subtype * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
}; // end class Result_list_subtype

//
// PDV_list_presentation_data_values
//

class ACSE_1_API PDV_list_presentation_data_values : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    PDV_list_presentation_data_values(const void* info) : Inherited(info) {}
public:
    PDV_list_presentation_data_values() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      single_ASN1_type0 = 0,
      octet_aligned1 = 1,
      arbitrary2 = 2
    };

    class single_ASN1_type
    {
    public:
        enum Id { eid = 0 };
        typedef ASN1::OpenData value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class single_ASN1_type

    single_ASN1_type::const_reference get_single_ASN1_type () const;
    single_ASN1_type::reference ref_single_ASN1_type ();
    single_ASN1_type::reference select_single_ASN1_type ();
    single_ASN1_type::reference select_single_ASN1_type (single_ASN1_type::const_reference v);
    bool single_ASN1_type_isSelected() const;

    PDV_list_presentation_data_values(single_ASN1_type::Id id, PDV_list_presentation_data_values::single_ASN1_type::const_reference v);

    class octet_aligned
    {
    public:
        enum Id { eid = 1 };
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class octet_aligned

    octet_aligned::const_reference get_octet_aligned () const;
    octet_aligned::reference ref_octet_aligned ();
    octet_aligned::reference select_octet_aligned ();
    octet_aligned::reference select_octet_aligned (const ASN1_STD vector<char>& v);
    bool octet_aligned_isSelected() const;

    PDV_list_presentation_data_values(octet_aligned::Id id, const ASN1_STD vector<char>& v);

    class arbitrary
    {
    public:
        enum Id { eid = 2 };
        typedef ASN1::BIT_STRING value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class arbitrary

    arbitrary::const_reference get_arbitrary () const;
    arbitrary::reference ref_arbitrary ();
    arbitrary::reference select_arbitrary ();
    arbitrary::reference select_arbitrary (arbitrary::const_reference v);
    bool arbitrary_isSelected() const;

    PDV_list_presentation_data_values(arbitrary::Id id, PDV_list_presentation_data_values::arbitrary::const_reference v);
    PDV_list_presentation_data_values(const PDV_list_presentation_data_values & that)     : Inherited(that) {}

    PDV_list_presentation_data_values & operator=(const PDV_list_presentation_data_values & that)
    { Inherited::operator=(that); return *this; }

    void swap(PDV_list_presentation_data_values & that) { Inherited::swap(that); }

    PDV_list_presentation_data_values * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[3];
    static unsigned selectionTags[3];
    static const char* selectionNames[3];
}; // end class PDV_list_presentation_data_values

//
// CP_type_normal_mode_parameters_extensions
//

class ACSE_1_API CP_type_normal_mode_parameters_extensions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CP_type_normal_mode_parameters_extensions(const void* info) : Inherited(info) {}
public:
    CP_type_normal_mode_parameters_extensions() : Inherited(&theInfo) {}
    CP_type_normal_mode_parameters_extensions(const CP_type_normal_mode_parameters_extensions & that) : Inherited(that) {}

    CP_type_normal_mode_parameters_extensions& operator=(const CP_type_normal_mode_parameters_extensions& that)
    { Inherited::operator=(that); return *this; }

    void swap(CP_type_normal_mode_parameters_extensions& that);
    CP_type_normal_mode_parameters_extensions * clone() const;
    static const Inherited::InfoType theInfo;

private:
}; // end class CP_type_normal_mode_parameters_extensions

//
// ARP_PPDU
//

class ACSE_1_API ARP_PPDU : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    ARP_PPDU(const void* info) : Inherited(info) {}
public:
    ARP_PPDU() : Inherited(&theInfo) {}
    ARP_PPDU(const ARP_PPDU & that) : Inherited(that) {}

    ARP_PPDU& operator=(const ARP_PPDU& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_provider_reason,
      e_event_identifier
    };

    class provider_reason
    {
    public:
        typedef Abort_reason value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class provider_reason

    provider_reason::const_reference get_provider_reason () const;
    provider_reason::reference ref_provider_reason ();
    provider_reason::reference set_provider_reason ();
    provider_reason::reference set_provider_reason (provider_reason::value_type::int_type v);
    void omit_provider_reason ();
    bool provider_reason_isPresent () const;

    class event_identifier
    {
    public:
        typedef Event_identifier value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class event_identifier

    event_identifier::const_reference get_event_identifier () const;
    event_identifier::reference ref_event_identifier ();
    event_identifier::reference set_event_identifier ();
    event_identifier::reference set_event_identifier (event_identifier::value_type::int_type v);
    void omit_event_identifier ();
    bool event_identifier_isPresent () const;
    void swap(ARP_PPDU& that);
    ARP_PPDU * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
}; // end class ARP_PPDU

typedef Presentation_selector Called_presentation_selector;
typedef Presentation_selector Calling_presentation_selector;
typedef ASN1::SEQUENCE_OF<Context_list_subtype,  ASN1::SizeConstraint<ASN1::ExtendableConstraint, 0, 7 > >  Context_list;

//
// Default_context_name
//

class ACSE_1_API Default_context_name : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Default_context_name(const void* info) : Inherited(info) {}
public:
    Default_context_name() : Inherited(&theInfo) {}
    Default_context_name(const Default_context_name & that) : Inherited(that) {}

    Default_context_name& operator=(const Default_context_name& that)
    { Inherited::operator=(that); return *this; }


    class abstract_syntax_name
    {
    public:
        typedef Abstract_syntax_name value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class abstract_syntax_name

    abstract_syntax_name::const_reference get_abstract_syntax_name () const;
    abstract_syntax_name::reference ref_abstract_syntax_name ();
    abstract_syntax_name::reference set_abstract_syntax_name ();
    abstract_syntax_name::reference set_abstract_syntax_name (abstract_syntax_name::const_reference v);

    class transfer_syntax_name
    {
    public:
        typedef Transfer_syntax_name value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class transfer_syntax_name

    transfer_syntax_name::const_reference get_transfer_syntax_name () const;
    transfer_syntax_name::reference ref_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name (transfer_syntax_name::const_reference v);
    void swap(Default_context_name& that);
    Default_context_name * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
}; // end class Default_context_name

typedef Result Default_context_result;
typedef Context_list Presentation_context_addition_list;
typedef Context_list Presentation_context_definition_list;
typedef ASN1::SEQUENCE_OF<Presentation_context_identifier,  ASN1::SizeConstraint<ASN1::ExtendableConstraint, 0, 7 > >  Presentation_context_deletion_list;

typedef ASN1::SEQUENCE_OF<Presentation_context_deletion_result_list_subtype,  ASN1::SizeConstraint<ASN1::ExtendableConstraint, 0, 7 > >  Presentation_context_deletion_result_list;

typedef ASN1::SEQUENCE_OF<Presentation_context_identifier_list_subtype,  ASN1::SizeConstraint<ASN1::ExtendableConstraint, 0, 7 > >  Presentation_context_identifier_list;

typedef ASN1::SEQUENCE_OF<Result_list_subtype,  ASN1::SizeConstraint<ASN1::ExtendableConstraint, 0, 7 > >  Result_list;

//
// PDV_list
//

class ACSE_1_API PDV_list : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    PDV_list(const void* info) : Inherited(info) {}
public:
    PDV_list() : Inherited(&theInfo) {}
    PDV_list(const PDV_list & that) : Inherited(that) {}

    PDV_list& operator=(const PDV_list& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_transfer_syntax_name
    };

    class transfer_syntax_name
    {
    public:
        typedef Transfer_syntax_name value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class transfer_syntax_name

    transfer_syntax_name::const_reference get_transfer_syntax_name () const;
    transfer_syntax_name::reference ref_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name ();
    transfer_syntax_name::reference set_transfer_syntax_name (transfer_syntax_name::const_reference v);
    void omit_transfer_syntax_name ();
    bool transfer_syntax_name_isPresent () const;

    class presentation_context_identifier
    {
    public:
        typedef Presentation_context_identifier value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_identifier

    presentation_context_identifier::const_reference get_presentation_context_identifier () const;
    presentation_context_identifier::reference ref_presentation_context_identifier ();
    presentation_context_identifier::reference set_presentation_context_identifier ();
    presentation_context_identifier::reference set_presentation_context_identifier (presentation_context_identifier::value_type::int_type v);

    class presentation_data_values
    {
    public:
        typedef PDV_list_presentation_data_values value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_data_values

    presentation_data_values::const_reference get_presentation_data_values () const;
    presentation_data_values::reference ref_presentation_data_values ();
    presentation_data_values::reference set_presentation_data_values ();
    presentation_data_values::reference set_presentation_data_values (presentation_data_values::const_reference v);
    void swap(PDV_list& that);
    PDV_list * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
}; // end class PDV_list

typedef Result_list Presentation_context_addition_result_list;
typedef Result_list Presentation_context_definition_result_list;
typedef ASN1::SEQUENCE_OF<PDV_list,  ASN1::SizeConstraint<ASN1::ExtendableConstraint, 1, 1 > >  Fully_encoded_data;

//
// User_data
//

class ACSE_1_API User_data : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    User_data(const void* info) : Inherited(info) {}
public:
    User_data() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      simply_encoded_data0 = 0,
      fully_encoded_data1 = 1
    };

    class simply_encoded_data
    {
    public:
        enum Id { eid = 0 };
        typedef Simply_encoded_data value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class simply_encoded_data

    simply_encoded_data::const_reference get_simply_encoded_data () const;
    simply_encoded_data::reference ref_simply_encoded_data ();
    simply_encoded_data::reference select_simply_encoded_data ();
    simply_encoded_data::reference select_simply_encoded_data (const ASN1_STD vector<char>& v);
    bool simply_encoded_data_isSelected() const;

    User_data(simply_encoded_data::Id id, const ASN1_STD vector<char>& v);

    class fully_encoded_data
    {
    public:
        enum Id { eid = 1 };
        typedef Fully_encoded_data value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class fully_encoded_data

    fully_encoded_data::const_reference get_fully_encoded_data () const;
    fully_encoded_data::reference ref_fully_encoded_data ();
    fully_encoded_data::reference select_fully_encoded_data ();
    fully_encoded_data::reference select_fully_encoded_data (fully_encoded_data::const_reference v);
    bool fully_encoded_data_isSelected() const;

    User_data(fully_encoded_data::Id id, User_data::fully_encoded_data::const_reference v);
    User_data(const User_data & that)     : Inherited(that) {}

    User_data & operator=(const User_data & that)
    { Inherited::operator=(that); return *this; }

    void swap(User_data & that) { Inherited::swap(that); }

    User_data * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[2];
    static unsigned selectionTags[2];
    static const char* selectionNames[2];
}; // end class User_data

//
// CP_type_normal_mode_parameters
//

class ACSE_1_API CP_type_normal_mode_parameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CP_type_normal_mode_parameters(const void* info) : Inherited(info) {}
public:
    CP_type_normal_mode_parameters() : Inherited(&theInfo) {}
    CP_type_normal_mode_parameters(const CP_type_normal_mode_parameters & that) : Inherited(that) {}

    CP_type_normal_mode_parameters& operator=(const CP_type_normal_mode_parameters& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_protocol_version,
      e_calling_presentation_selector,
      e_called_presentation_selector,
      e_presentation_context_definition_list,
      e_default_context_name,
      e_presentation_requirements,
      e_user_session_requirements,
      e_protocol_options,
      e_initiators_nominated_context,
      e_extensions,
      e_user_data
    };

    class protocol_version
    {
    public:
        typedef Protocol_version value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class protocol_version

    protocol_version::const_reference get_protocol_version () const;
    protocol_version::reference ref_protocol_version ();
    protocol_version::reference set_protocol_version ();
    protocol_version::reference set_protocol_version (protocol_version::const_reference v);
    void omit_protocol_version ();
    bool protocol_version_isPresent () const;

    class calling_presentation_selector
    {
    public:
        typedef Calling_presentation_selector value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class calling_presentation_selector

    calling_presentation_selector::const_reference get_calling_presentation_selector () const;
    calling_presentation_selector::reference ref_calling_presentation_selector ();
    calling_presentation_selector::reference set_calling_presentation_selector ();
    calling_presentation_selector::reference set_calling_presentation_selector (const ASN1_STD vector<char>& v);
    void omit_calling_presentation_selector ();
    bool calling_presentation_selector_isPresent () const;

    class called_presentation_selector
    {
    public:
        typedef Called_presentation_selector value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class called_presentation_selector

    called_presentation_selector::const_reference get_called_presentation_selector () const;
    called_presentation_selector::reference ref_called_presentation_selector ();
    called_presentation_selector::reference set_called_presentation_selector ();
    called_presentation_selector::reference set_called_presentation_selector (const ASN1_STD vector<char>& v);
    void omit_called_presentation_selector ();
    bool called_presentation_selector_isPresent () const;

    class presentation_context_definition_list
    {
    public:
        typedef Presentation_context_definition_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_definition_list

    presentation_context_definition_list::const_reference get_presentation_context_definition_list () const;
    presentation_context_definition_list::reference ref_presentation_context_definition_list ();
    presentation_context_definition_list::reference set_presentation_context_definition_list ();
    presentation_context_definition_list::reference set_presentation_context_definition_list (presentation_context_definition_list::const_reference v);
    void omit_presentation_context_definition_list ();
    bool presentation_context_definition_list_isPresent () const;

    class default_context_name
    {
    public:
        typedef Default_context_name value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class default_context_name

    default_context_name::const_reference get_default_context_name () const;
    default_context_name::reference ref_default_context_name ();
    default_context_name::reference set_default_context_name ();
    default_context_name::reference set_default_context_name (default_context_name::const_reference v);
    void omit_default_context_name ();
    bool default_context_name_isPresent () const;

    class presentation_requirements
    {
    public:
        typedef Presentation_requirements value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_requirements

    presentation_requirements::const_reference get_presentation_requirements () const;
    presentation_requirements::reference ref_presentation_requirements ();
    presentation_requirements::reference set_presentation_requirements ();
    presentation_requirements::reference set_presentation_requirements (presentation_requirements::const_reference v);
    void omit_presentation_requirements ();
    bool presentation_requirements_isPresent () const;

    class user_session_requirements
    {
    public:
        typedef User_session_requirements value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_session_requirements

    user_session_requirements::const_reference get_user_session_requirements () const;
    user_session_requirements::reference ref_user_session_requirements ();
    user_session_requirements::reference set_user_session_requirements ();
    user_session_requirements::reference set_user_session_requirements (user_session_requirements::const_reference v);
    void omit_user_session_requirements ();
    bool user_session_requirements_isPresent () const;

    class protocol_options
    {
    public:
        typedef Protocol_options value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class protocol_options

    protocol_options::const_reference get_protocol_options () const;
    protocol_options::reference ref_protocol_options ();
    protocol_options::reference set_protocol_options ();
    protocol_options::reference set_protocol_options (protocol_options::const_reference v);
    void omit_protocol_options ();
    bool protocol_options_isPresent () const;

    class initiators_nominated_context
    {
    public:
        typedef Presentation_context_identifier value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class initiators_nominated_context

    initiators_nominated_context::const_reference get_initiators_nominated_context () const;
    initiators_nominated_context::reference ref_initiators_nominated_context ();
    initiators_nominated_context::reference set_initiators_nominated_context ();
    initiators_nominated_context::reference set_initiators_nominated_context (initiators_nominated_context::value_type::int_type v);
    void omit_initiators_nominated_context ();
    bool initiators_nominated_context_isPresent () const;

    class extensions
    {
    public:
        typedef CP_type_normal_mode_parameters_extensions value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class extensions

    extensions::const_reference get_extensions () const;
    extensions::reference ref_extensions ();
    extensions::reference set_extensions ();
    extensions::reference set_extensions (extensions::const_reference v);
    void omit_extensions ();
    bool extensions_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(CP_type_normal_mode_parameters& that);
    CP_type_normal_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[11];
    static int fieldIds[11];
    static unsigned fieldTags[11];
    static const char* fieldNames[11];
}; // end class CP_type_normal_mode_parameters

//
// CPA_PPDU_normal_mode_parameters
//

class ACSE_1_API CPA_PPDU_normal_mode_parameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CPA_PPDU_normal_mode_parameters(const void* info) : Inherited(info) {}
public:
    CPA_PPDU_normal_mode_parameters() : Inherited(&theInfo) {}
    CPA_PPDU_normal_mode_parameters(const CPA_PPDU_normal_mode_parameters & that) : Inherited(that) {}

    CPA_PPDU_normal_mode_parameters& operator=(const CPA_PPDU_normal_mode_parameters& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_protocol_version,
      e_responding_presentation_selector,
      e_presentation_context_definition_result_list,
      e_presentation_requirements,
      e_user_session_requirements,
      e_protocol_options,
      e_responders_nominated_context,
      e_user_data
    };

    class protocol_version
    {
    public:
        typedef Protocol_version value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class protocol_version

    protocol_version::const_reference get_protocol_version () const;
    protocol_version::reference ref_protocol_version ();
    protocol_version::reference set_protocol_version ();
    protocol_version::reference set_protocol_version (protocol_version::const_reference v);
    void omit_protocol_version ();
    bool protocol_version_isPresent () const;

    class responding_presentation_selector
    {
    public:
        typedef Responding_presentation_selector value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class responding_presentation_selector

    responding_presentation_selector::const_reference get_responding_presentation_selector () const;
    responding_presentation_selector::reference ref_responding_presentation_selector ();
    responding_presentation_selector::reference set_responding_presentation_selector ();
    responding_presentation_selector::reference set_responding_presentation_selector (const ASN1_STD vector<char>& v);
    void omit_responding_presentation_selector ();
    bool responding_presentation_selector_isPresent () const;

    class presentation_context_definition_result_list
    {
    public:
        typedef Presentation_context_definition_result_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_definition_result_list

    presentation_context_definition_result_list::const_reference get_presentation_context_definition_result_list () const;
    presentation_context_definition_result_list::reference ref_presentation_context_definition_result_list ();
    presentation_context_definition_result_list::reference set_presentation_context_definition_result_list ();
    presentation_context_definition_result_list::reference set_presentation_context_definition_result_list (presentation_context_definition_result_list::const_reference v);
    void omit_presentation_context_definition_result_list ();
    bool presentation_context_definition_result_list_isPresent () const;

    class presentation_requirements
    {
    public:
        typedef Presentation_requirements value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_requirements

    presentation_requirements::const_reference get_presentation_requirements () const;
    presentation_requirements::reference ref_presentation_requirements ();
    presentation_requirements::reference set_presentation_requirements ();
    presentation_requirements::reference set_presentation_requirements (presentation_requirements::const_reference v);
    void omit_presentation_requirements ();
    bool presentation_requirements_isPresent () const;

    class user_session_requirements
    {
    public:
        typedef User_session_requirements value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_session_requirements

    user_session_requirements::const_reference get_user_session_requirements () const;
    user_session_requirements::reference ref_user_session_requirements ();
    user_session_requirements::reference set_user_session_requirements ();
    user_session_requirements::reference set_user_session_requirements (user_session_requirements::const_reference v);
    void omit_user_session_requirements ();
    bool user_session_requirements_isPresent () const;

    class protocol_options
    {
    public:
        typedef Protocol_options value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class protocol_options

    protocol_options::const_reference get_protocol_options () const;
    protocol_options::reference ref_protocol_options ();
    protocol_options::reference set_protocol_options ();
    protocol_options::reference set_protocol_options (protocol_options::const_reference v);
    void omit_protocol_options ();
    bool protocol_options_isPresent () const;

    class responders_nominated_context
    {
    public:
        typedef Presentation_context_identifier value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class responders_nominated_context

    responders_nominated_context::const_reference get_responders_nominated_context () const;
    responders_nominated_context::reference ref_responders_nominated_context ();
    responders_nominated_context::reference set_responders_nominated_context ();
    responders_nominated_context::reference set_responders_nominated_context (responders_nominated_context::value_type::int_type v);
    void omit_responders_nominated_context ();
    bool responders_nominated_context_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(CPA_PPDU_normal_mode_parameters& that);
    CPA_PPDU_normal_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[8];
    static int fieldIds[8];
    static unsigned fieldTags[8];
    static const char* fieldNames[8];
}; // end class CPA_PPDU_normal_mode_parameters

//
// CPR_PPDU_normal_mode_parameters
//

class ACSE_1_API CPR_PPDU_normal_mode_parameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CPR_PPDU_normal_mode_parameters(const void* info) : Inherited(info) {}
public:
    CPR_PPDU_normal_mode_parameters() : Inherited(&theInfo) {}
    CPR_PPDU_normal_mode_parameters(const CPR_PPDU_normal_mode_parameters & that) : Inherited(that) {}

    CPR_PPDU_normal_mode_parameters& operator=(const CPR_PPDU_normal_mode_parameters& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_protocol_version,
      e_responding_presentation_selector,
      e_presentation_context_definition_result_list,
      e_default_context_result,
      e_provider_reason,
      e_user_data
    };

    class protocol_version
    {
    public:
        typedef Protocol_version value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class protocol_version

    protocol_version::const_reference get_protocol_version () const;
    protocol_version::reference ref_protocol_version ();
    protocol_version::reference set_protocol_version ();
    protocol_version::reference set_protocol_version (protocol_version::const_reference v);
    void omit_protocol_version ();
    bool protocol_version_isPresent () const;

    class responding_presentation_selector
    {
    public:
        typedef Responding_presentation_selector value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class responding_presentation_selector

    responding_presentation_selector::const_reference get_responding_presentation_selector () const;
    responding_presentation_selector::reference ref_responding_presentation_selector ();
    responding_presentation_selector::reference set_responding_presentation_selector ();
    responding_presentation_selector::reference set_responding_presentation_selector (const ASN1_STD vector<char>& v);
    void omit_responding_presentation_selector ();
    bool responding_presentation_selector_isPresent () const;

    class presentation_context_definition_result_list
    {
    public:
        typedef Presentation_context_definition_result_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_definition_result_list

    presentation_context_definition_result_list::const_reference get_presentation_context_definition_result_list () const;
    presentation_context_definition_result_list::reference ref_presentation_context_definition_result_list ();
    presentation_context_definition_result_list::reference set_presentation_context_definition_result_list ();
    presentation_context_definition_result_list::reference set_presentation_context_definition_result_list (presentation_context_definition_result_list::const_reference v);
    void omit_presentation_context_definition_result_list ();
    bool presentation_context_definition_result_list_isPresent () const;

    class default_context_result
    {
    public:
        typedef Default_context_result value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class default_context_result

    default_context_result::const_reference get_default_context_result () const;
    default_context_result::reference ref_default_context_result ();
    default_context_result::reference set_default_context_result ();
    default_context_result::reference set_default_context_result (default_context_result::value_type::int_type v);
    void omit_default_context_result ();
    bool default_context_result_isPresent () const;

    class provider_reason
    {
    public:
        typedef Provider_reason value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class provider_reason

    provider_reason::const_reference get_provider_reason () const;
    provider_reason::reference ref_provider_reason ();
    provider_reason::reference set_provider_reason ();
    provider_reason::reference set_provider_reason (provider_reason::value_type::int_type v);
    void omit_provider_reason ();
    bool provider_reason_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(CPR_PPDU_normal_mode_parameters& that);
    CPR_PPDU_normal_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static unsigned fieldTags[6];
    static const char* fieldNames[6];
}; // end class CPR_PPDU_normal_mode_parameters

//
// ARU_PPDU_normal_mode_parameters
//

class ACSE_1_API ARU_PPDU_normal_mode_parameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    ARU_PPDU_normal_mode_parameters(const void* info) : Inherited(info) {}
public:
    ARU_PPDU_normal_mode_parameters() : Inherited(&theInfo) {}
    ARU_PPDU_normal_mode_parameters(const ARU_PPDU_normal_mode_parameters & that) : Inherited(that) {}

    ARU_PPDU_normal_mode_parameters& operator=(const ARU_PPDU_normal_mode_parameters& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_presentation_context_identifier_list,
      e_user_data
    };

    class presentation_context_identifier_list
    {
    public:
        typedef Presentation_context_identifier_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_identifier_list

    presentation_context_identifier_list::const_reference get_presentation_context_identifier_list () const;
    presentation_context_identifier_list::reference ref_presentation_context_identifier_list ();
    presentation_context_identifier_list::reference set_presentation_context_identifier_list ();
    presentation_context_identifier_list::reference set_presentation_context_identifier_list (presentation_context_identifier_list::const_reference v);
    void omit_presentation_context_identifier_list ();
    bool presentation_context_identifier_list_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(ARU_PPDU_normal_mode_parameters& that);
    ARU_PPDU_normal_mode_parameters * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static unsigned fieldTags[2];
    static const char* fieldNames[2];
}; // end class ARU_PPDU_normal_mode_parameters

//
// CP_type
//

class ACSE_1_API CP_type : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CP_type(const void* info) : Inherited(info) {}
public:
    CP_type() : Inherited(&theInfo) {}
    CP_type(const CP_type & that) : Inherited(that) {}

    CP_type& operator=(const CP_type& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_x410_mode_parameters,
      e_normal_mode_parameters
    };

    class mode_selector
    {
    public:
        typedef Mode_selector value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class mode_selector

    mode_selector::const_reference get_mode_selector () const;
    mode_selector::reference ref_mode_selector ();
    mode_selector::reference set_mode_selector ();
    mode_selector::reference set_mode_selector (mode_selector::const_reference v);

    class x410_mode_parameters
    {
    public:
        typedef CP_type_x410_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class x410_mode_parameters

    x410_mode_parameters::const_reference get_x410_mode_parameters () const;
    x410_mode_parameters::reference ref_x410_mode_parameters ();
    x410_mode_parameters::reference set_x410_mode_parameters ();
    x410_mode_parameters::reference set_x410_mode_parameters (x410_mode_parameters::const_reference v);
    void omit_x410_mode_parameters ();
    bool x410_mode_parameters_isPresent () const;

    class normal_mode_parameters
    {
    public:
        typedef CP_type_normal_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class normal_mode_parameters

    normal_mode_parameters::const_reference get_normal_mode_parameters () const;
    normal_mode_parameters::reference ref_normal_mode_parameters ();
    normal_mode_parameters::reference set_normal_mode_parameters ();
    normal_mode_parameters::reference set_normal_mode_parameters (normal_mode_parameters::const_reference v);
    void omit_normal_mode_parameters ();
    bool normal_mode_parameters_isPresent () const;
    void swap(CP_type& that);
    CP_type * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
}; // end class CP_type

typedef User_data CPC_type;
//
// CPA_PPDU
//

class ACSE_1_API CPA_PPDU : public ASN1::SET
{
    typedef ASN1::SET Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CPA_PPDU(const void* info) : Inherited(info) {}
public:
    CPA_PPDU() : Inherited(&theInfo) {}
    CPA_PPDU(const CPA_PPDU & that) : Inherited(that) {}

    CPA_PPDU& operator=(const CPA_PPDU& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_x410_mode_parameters,
      e_normal_mode_parameters
    };

    class mode_selector
    {
    public:
        typedef Mode_selector value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class mode_selector

    mode_selector::const_reference get_mode_selector () const;
    mode_selector::reference ref_mode_selector ();
    mode_selector::reference set_mode_selector ();
    mode_selector::reference set_mode_selector (mode_selector::const_reference v);

    class x410_mode_parameters
    {
    public:
        typedef CPA_PPDU_x410_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class x410_mode_parameters

    x410_mode_parameters::const_reference get_x410_mode_parameters () const;
    x410_mode_parameters::reference ref_x410_mode_parameters ();
    x410_mode_parameters::reference set_x410_mode_parameters ();
    x410_mode_parameters::reference set_x410_mode_parameters (x410_mode_parameters::const_reference v);
    void omit_x410_mode_parameters ();
    bool x410_mode_parameters_isPresent () const;

    class normal_mode_parameters
    {
    public:
        typedef CPA_PPDU_normal_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class normal_mode_parameters

    normal_mode_parameters::const_reference get_normal_mode_parameters () const;
    normal_mode_parameters::reference ref_normal_mode_parameters ();
    normal_mode_parameters::reference set_normal_mode_parameters ();
    normal_mode_parameters::reference set_normal_mode_parameters (normal_mode_parameters::const_reference v);
    void omit_normal_mode_parameters ();
    bool normal_mode_parameters_isPresent () const;
    void swap(CPA_PPDU& that);
    CPA_PPDU * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
}; // end class CPA_PPDU

//
// CPR_PPDU
//

class ACSE_1_API CPR_PPDU : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    CPR_PPDU(const void* info) : Inherited(info) {}
public:
    CPR_PPDU() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      x400_mode_parameters0 = 0,
      normal_mode_parameters1 = 1
    };

    class x400_mode_parameters
    {
    public:
        enum Id { eid = 0 };
        typedef CPR_PPDU_x400_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class x400_mode_parameters

    x400_mode_parameters::const_reference get_x400_mode_parameters () const;
    x400_mode_parameters::reference ref_x400_mode_parameters ();
    x400_mode_parameters::reference select_x400_mode_parameters ();
    x400_mode_parameters::reference select_x400_mode_parameters (x400_mode_parameters::const_reference v);
    bool x400_mode_parameters_isSelected() const;

    CPR_PPDU(x400_mode_parameters::Id id, CPR_PPDU::x400_mode_parameters::const_reference v);

    class normal_mode_parameters
    {
    public:
        enum Id { eid = 1 };
        typedef CPR_PPDU_normal_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class normal_mode_parameters

    normal_mode_parameters::const_reference get_normal_mode_parameters () const;
    normal_mode_parameters::reference ref_normal_mode_parameters ();
    normal_mode_parameters::reference select_normal_mode_parameters ();
    normal_mode_parameters::reference select_normal_mode_parameters (normal_mode_parameters::const_reference v);
    bool normal_mode_parameters_isSelected() const;

    CPR_PPDU(normal_mode_parameters::Id id, CPR_PPDU::normal_mode_parameters::const_reference v);
    CPR_PPDU(const CPR_PPDU & that)     : Inherited(that) {}

    CPR_PPDU & operator=(const CPR_PPDU & that)
    { Inherited::operator=(that); return *this; }

    void swap(CPR_PPDU & that) { Inherited::swap(that); }

    CPR_PPDU * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[2];
    static unsigned selectionTags[2];
    static const char* selectionNames[2];
}; // end class CPR_PPDU

//
// ARU_PPDU
//

class ACSE_1_API ARU_PPDU : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    ARU_PPDU(const void* info) : Inherited(info) {}
public:
    ARU_PPDU() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      x400_mode_parameters0 = 0,
      normal_mode_parameters1 = 1
    };

    class x400_mode_parameters
    {
    public:
        enum Id { eid = 0 };
        typedef ARU_PPDU_x400_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class x400_mode_parameters

    x400_mode_parameters::const_reference get_x400_mode_parameters () const;
    x400_mode_parameters::reference ref_x400_mode_parameters ();
    x400_mode_parameters::reference select_x400_mode_parameters ();
    x400_mode_parameters::reference select_x400_mode_parameters (x400_mode_parameters::const_reference v);
    bool x400_mode_parameters_isSelected() const;

    ARU_PPDU(x400_mode_parameters::Id id, ARU_PPDU::x400_mode_parameters::const_reference v);

    class normal_mode_parameters
    {
    public:
        enum Id { eid = 1 };
        typedef ARU_PPDU_normal_mode_parameters value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class normal_mode_parameters

    normal_mode_parameters::const_reference get_normal_mode_parameters () const;
    normal_mode_parameters::reference ref_normal_mode_parameters ();
    normal_mode_parameters::reference select_normal_mode_parameters ();
    normal_mode_parameters::reference select_normal_mode_parameters (normal_mode_parameters::const_reference v);
    bool normal_mode_parameters_isSelected() const;

    ARU_PPDU(normal_mode_parameters::Id id, ARU_PPDU::normal_mode_parameters::const_reference v);
    ARU_PPDU(const ARU_PPDU & that)     : Inherited(that) {}

    ARU_PPDU & operator=(const ARU_PPDU & that)
    { Inherited::operator=(that); return *this; }

    void swap(ARU_PPDU & that) { Inherited::swap(that); }

    ARU_PPDU * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[2];
    static unsigned selectionTags[2];
    static const char* selectionNames[2];
}; // end class ARU_PPDU

//
// AC_PPDU
//

class ACSE_1_API AC_PPDU : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    AC_PPDU(const void* info) : Inherited(info) {}
public:
    AC_PPDU() : Inherited(&theInfo) {}
    AC_PPDU(const AC_PPDU & that) : Inherited(that) {}

    AC_PPDU& operator=(const AC_PPDU& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_presentation_context_addition_list,
      e_presentation_context_deletion_list,
      e_user_data
    };

    class presentation_context_addition_list
    {
    public:
        typedef Presentation_context_addition_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_addition_list

    presentation_context_addition_list::const_reference get_presentation_context_addition_list () const;
    presentation_context_addition_list::reference ref_presentation_context_addition_list ();
    presentation_context_addition_list::reference set_presentation_context_addition_list ();
    presentation_context_addition_list::reference set_presentation_context_addition_list (presentation_context_addition_list::const_reference v);
    void omit_presentation_context_addition_list ();
    bool presentation_context_addition_list_isPresent () const;

    class presentation_context_deletion_list
    {
    public:
        typedef Presentation_context_deletion_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_deletion_list

    presentation_context_deletion_list::const_reference get_presentation_context_deletion_list () const;
    presentation_context_deletion_list::reference ref_presentation_context_deletion_list ();
    presentation_context_deletion_list::reference set_presentation_context_deletion_list ();
    presentation_context_deletion_list::reference set_presentation_context_deletion_list (presentation_context_deletion_list::const_reference v);
    void omit_presentation_context_deletion_list ();
    bool presentation_context_deletion_list_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(AC_PPDU& that);
    AC_PPDU * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static unsigned fieldTags[3];
    static const char* fieldNames[3];
}; // end class AC_PPDU

//
// ACA_PPDU
//

class ACSE_1_API ACA_PPDU : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    ACA_PPDU(const void* info) : Inherited(info) {}
public:
    ACA_PPDU() : Inherited(&theInfo) {}
    ACA_PPDU(const ACA_PPDU & that) : Inherited(that) {}

    ACA_PPDU& operator=(const ACA_PPDU& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_presentation_context_addition_result_list,
      e_presentation_context_deletion_result_list,
      e_user_data
    };

    class presentation_context_addition_result_list
    {
    public:
        typedef Presentation_context_addition_result_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_addition_result_list

    presentation_context_addition_result_list::const_reference get_presentation_context_addition_result_list () const;
    presentation_context_addition_result_list::reference ref_presentation_context_addition_result_list ();
    presentation_context_addition_result_list::reference set_presentation_context_addition_result_list ();
    presentation_context_addition_result_list::reference set_presentation_context_addition_result_list (presentation_context_addition_result_list::const_reference v);
    void omit_presentation_context_addition_result_list ();
    bool presentation_context_addition_result_list_isPresent () const;

    class presentation_context_deletion_result_list
    {
    public:
        typedef Presentation_context_deletion_result_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_deletion_result_list

    presentation_context_deletion_result_list::const_reference get_presentation_context_deletion_result_list () const;
    presentation_context_deletion_result_list::reference ref_presentation_context_deletion_result_list ();
    presentation_context_deletion_result_list::reference set_presentation_context_deletion_result_list ();
    presentation_context_deletion_result_list::reference set_presentation_context_deletion_result_list (presentation_context_deletion_result_list::const_reference v);
    void omit_presentation_context_deletion_result_list ();
    bool presentation_context_deletion_result_list_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(ACA_PPDU& that);
    ACA_PPDU * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static unsigned fieldTags[3];
    static const char* fieldNames[3];
}; // end class ACA_PPDU

//
// RS_PPDU
//

class ACSE_1_API RS_PPDU : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RS_PPDU(const void* info) : Inherited(info) {}
public:
    RS_PPDU() : Inherited(&theInfo) {}
    RS_PPDU(const RS_PPDU & that) : Inherited(that) {}

    RS_PPDU& operator=(const RS_PPDU& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_presentation_context_identifier_list,
      e_user_data
    };

    class presentation_context_identifier_list
    {
    public:
        typedef Presentation_context_identifier_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_identifier_list

    presentation_context_identifier_list::const_reference get_presentation_context_identifier_list () const;
    presentation_context_identifier_list::reference ref_presentation_context_identifier_list ();
    presentation_context_identifier_list::reference set_presentation_context_identifier_list ();
    presentation_context_identifier_list::reference set_presentation_context_identifier_list (presentation_context_identifier_list::const_reference v);
    void omit_presentation_context_identifier_list ();
    bool presentation_context_identifier_list_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(RS_PPDU& that);
    RS_PPDU * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static unsigned fieldTags[2];
    static const char* fieldNames[2];
}; // end class RS_PPDU

//
// RSA_PPDU
//

class ACSE_1_API RSA_PPDU : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    RSA_PPDU(const void* info) : Inherited(info) {}
public:
    RSA_PPDU() : Inherited(&theInfo) {}
    RSA_PPDU(const RSA_PPDU & that) : Inherited(that) {}

    RSA_PPDU& operator=(const RSA_PPDU& that)
    { Inherited::operator=(that); return *this; }

    enum OptionalFields {
      e_presentation_context_identifier_list,
      e_user_data
    };

    class presentation_context_identifier_list
    {
    public:
        typedef Presentation_context_identifier_list value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class presentation_context_identifier_list

    presentation_context_identifier_list::const_reference get_presentation_context_identifier_list () const;
    presentation_context_identifier_list::reference ref_presentation_context_identifier_list ();
    presentation_context_identifier_list::reference set_presentation_context_identifier_list ();
    presentation_context_identifier_list::reference set_presentation_context_identifier_list (presentation_context_identifier_list::const_reference v);
    void omit_presentation_context_identifier_list ();
    bool presentation_context_identifier_list_isPresent () const;

    class user_data
    {
    public:
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class user_data

    user_data::const_reference get_user_data () const;
    user_data::reference ref_user_data ();
    user_data::reference set_user_data ();
    user_data::reference set_user_data (user_data::const_reference v);
    void omit_user_data ();
    bool user_data_isPresent () const;
    void swap(RSA_PPDU& that);
    RSA_PPDU * clone() const;
    static const Inherited::InfoType theInfo;

private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static unsigned fieldTags[2];
    static const char* fieldNames[2];
}; // end class RSA_PPDU

//
// Abort_type
//

class ACSE_1_API Abort_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Abort_type(const void* info) : Inherited(info) {}
public:
    Abort_type() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      aru_ppdu0 = 0,
      arp_ppdu1 = 1
    };

    class aru_ppdu
    {
    public:
        enum Id { eid = 0 };
        typedef ARU_PPDU value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class aru_ppdu

    aru_ppdu::const_reference get_aru_ppdu () const;
    aru_ppdu::reference ref_aru_ppdu ();
    aru_ppdu::reference select_aru_ppdu ();
    aru_ppdu::reference select_aru_ppdu (aru_ppdu::const_reference v);
    bool aru_ppdu_isSelected() const;

    Abort_type(aru_ppdu::Id id, Abort_type::aru_ppdu::const_reference v);

    class arp_ppdu
    {
    public:
        enum Id { eid = 1 };
        typedef ARP_PPDU value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class arp_ppdu

    arp_ppdu::const_reference get_arp_ppdu () const;
    arp_ppdu::reference ref_arp_ppdu ();
    arp_ppdu::reference select_arp_ppdu ();
    arp_ppdu::reference select_arp_ppdu (arp_ppdu::const_reference v);
    bool arp_ppdu_isSelected() const;

    Abort_type(arp_ppdu::Id id, Abort_type::arp_ppdu::const_reference v);
    Abort_type(const Abort_type & that)     : Inherited(that) {}

    Abort_type & operator=(const Abort_type & that)
    { Inherited::operator=(that); return *this; }

    void swap(Abort_type & that) { Inherited::swap(that); }

    Abort_type * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[2];
    static unsigned selectionTags[2];
    static const char* selectionNames[2];
}; // end class Abort_type

//
// Typed_data_type
//

class ACSE_1_API Typed_data_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
protected:
    typedef Inherited::InfoType InfoType;
    Typed_data_type(const void* info) : Inherited(info) {}
public:
    Typed_data_type() : Inherited(&theInfo) {}
    enum Choice_Ids {
      unknownSelection_ = -2,
      unselected_ = -1,
      acPPDU0 = 0,
      acaPPDU1 = 1,
      ttdPPDU2 = 2
    };

    class acPPDU
    {
    public:
        enum Id { eid = 0 };
        typedef AC_PPDU value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class acPPDU

    acPPDU::const_reference get_acPPDU () const;
    acPPDU::reference ref_acPPDU ();
    acPPDU::reference select_acPPDU ();
    acPPDU::reference select_acPPDU (acPPDU::const_reference v);
    bool acPPDU_isSelected() const;

    Typed_data_type(acPPDU::Id id, Typed_data_type::acPPDU::const_reference v);

    class acaPPDU
    {
    public:
        enum Id { eid = 1 };
        typedef ACA_PPDU value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class acaPPDU

    acaPPDU::const_reference get_acaPPDU () const;
    acaPPDU::reference ref_acaPPDU ();
    acaPPDU::reference select_acaPPDU ();
    acaPPDU::reference select_acaPPDU (acaPPDU::const_reference v);
    bool acaPPDU_isSelected() const;

    Typed_data_type(acaPPDU::Id id, Typed_data_type::acaPPDU::const_reference v);

    class ttdPPDU
    {
    public:
        enum Id { eid = 2 };
        typedef User_data value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class ttdPPDU

    ttdPPDU::const_reference get_ttdPPDU () const;
    ttdPPDU::reference ref_ttdPPDU ();
    ttdPPDU::reference select_ttdPPDU ();
    ttdPPDU::reference select_ttdPPDU (ttdPPDU::const_reference v);
    bool ttdPPDU_isSelected() const;

    Typed_data_type(ttdPPDU::Id id, Typed_data_type::ttdPPDU::const_reference v);
    Typed_data_type(const Typed_data_type & that)     : Inherited(that) {}

    Typed_data_type & operator=(const Typed_data_type & that)
    { Inherited::operator=(that); return *this; }

    void swap(Typed_data_type & that) { Inherited::swap(that); }

    Typed_data_type * clone() const;
    static bool equal_type(const ASN1::AbstractData& type);
    static const InfoType theInfo;
private:
    static const void* selectionInfos[3];
    static unsigned selectionTags[3];
    static const char* selectionNames[3];
}; // end class Typed_data_type

#include "iso8823_presentation.inl"

} // namespace ISO8823_PRESENTATION

#endif // __ISO8823_PRESENTATION_H

// End of iso8823_presentation.h
